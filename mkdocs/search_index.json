{
    "docs": [
        {
            "location": "/", 
            "text": "rpclib - modern msgpack-rpc for C++\n\n\nWelcome! \nrpclib\n is a msgpack-rpc library written using modern C++.\nThe goal of this library is to provide a simple, no-nonsense RPC solution.\n\nrpclib\n is compatible with C++11 and C++14 (currently the difference is that it compiles slightly\nfaster in C++14 mode).\n\n\nWhat does it look like?\n\n\nHere is a very simple example, a kind of hello world for network-related libraries, the \"echo\"\nserver and client:\n\n\n#include\n \nrpc/server.h\n\n\n#include\n \nstring\n\n\nusing\n \nstd\n::\nstring\n;\n\n\n\nint\n \nmain\n()\n \n{\n\n  \nrpc\n::\nserver\n \nsrv\n(\n8080\n);\n\n\n  \nsrv\n.\nbind\n(\necho\n,\n \n[](\nstring\n \nconst\n \ns\n)\n \n{\n\n    \nreturn\n \nstring\n(\n \n)\n \n+\n \ns\n;\n\n  \n});\n\n\n  \nsrv\n.\nrun\n();\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\n#include\n \nrpc/client.h\n\n\n#include\n \niostream\n\n\n#include\n \nstring\n\n\nusing\n \nstd\n::\nstring\n;\n\n\n\nint\n \nmain\n()\n \n{\n\n  \nrpc\n::\nclient\n \nc\n(\nlocalhost\n,\n \n8080\n);\n\n\n  \nstring\n \ninput\n,\n \nresult\n;\n\n  \nwhile\n \n(\nstd\n::\ngetline\n(\nstd\n::\ncin\n,\n \ninput\n))\n \n{\n\n    \nif\n \n(\n!\ninput\n.\nempty\n())\n \n{\n\n      \nresult\n \n=\n \nc\n.\ncall\n(\necho\n,\n \ninput\n).\nas\nstring\n();\n\n      \nstd\n::\ncout\n \n \nresult\n \n \nstd\n::\nendl\n;\n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\nFeatured chapters\n\n\n\n\nGetting started\n - How to set up your environment to start using \nrpclib\n\n\nPrimer\n - A longer tutorial introduction to using the library, intended for newcomers\n\n\nCookbook\n - Lots of examples of common tasks the library was designed for handling", 
            "title": "Home"
        }, 
        {
            "location": "/#rpclib-modern-msgpack-rpc-for-c", 
            "text": "Welcome!  rpclib  is a msgpack-rpc library written using modern C++.\nThe goal of this library is to provide a simple, no-nonsense RPC solution. rpclib  is compatible with C++11 and C++14 (currently the difference is that it compiles slightly\nfaster in C++14 mode).", 
            "title": "rpclib - modern msgpack-rpc for C++"
        }, 
        {
            "location": "/#what-does-it-look-like", 
            "text": "Here is a very simple example, a kind of hello world for network-related libraries, the \"echo\"\nserver and client:  #include   rpc/server.h  #include   string  using   std :: string ;  int   main ()   { \n   rpc :: server   srv ( 8080 ); \n\n   srv . bind ( echo ,   []( string   const   s )   { \n     return   string (   )   +   s ; \n   }); \n\n   srv . run (); \n   return   0 ;  }   #include   rpc/client.h  #include   iostream  #include   string  using   std :: string ;  int   main ()   { \n   rpc :: client   c ( localhost ,   8080 ); \n\n   string   input ,   result ; \n   while   ( std :: getline ( std :: cin ,   input ))   { \n     if   ( ! input . empty ())   { \n       result   =   c . call ( echo ,   input ). as string (); \n       std :: cout     result     std :: endl ; \n     } \n   }  }", 
            "title": "What does it look like?"
        }, 
        {
            "location": "/#featured-chapters", 
            "text": "Getting started  - How to set up your environment to start using  rpclib  Primer  - A longer tutorial introduction to using the library, intended for newcomers  Cookbook  - Lots of examples of common tasks the library was designed for handling", 
            "title": "Featured chapters"
        }, 
        {
            "location": "/gettingstarted/", 
            "text": "This chapter details the steps of getting everything in place to be able to use \nrpclib\n.\n\n\nWhat you need\n\n\nCompiler\n\n\nrpclib\n is compatible with C++11, but it's also able to take advantage of C++14 if the compiler\nsupports it. At the moment, the oldest versions of the major compilers that are known to work\nare the following:\n\n\n\n\ng++ 4.8\n\n\nclang++ 3.7\n\n\nMSVC 2015 Update 3\n\n\n\n\nNewer versions of these compilers are expected to work, of course.\n\n\nSince C++11 support was introduced, it might be possible to compile rpclib with even older compilers.\nIf it builds and the unit tests run without an error then it should be fine to use (please report older compilers\nthat do compile but produce failing unit tests to the issue tracker!)\n\n\nTools\n\n\nIn addition to a capable compiler, you will need:\n\n\n\n\nCMake 3.x\n\n\nAnd either\n\n\nGNU make, or\n\n\nNinja, or\n\n\nMSBuild/Visual Studio (on Microsoft Windows).\n\n\n\n\n\n\n\n\nThe library\n\n\nThere are various release packages available for the most popular systems and ideally you should install one of those. If there is no suitable package for your system or you simply prefer to build from source, take a look at the \nCompiling\n chapter.\n\n\n\n\nInfo\n\n\nrpclib\n uses CMake and has a very conventional build process. If you know how to build a CMake-based library, you know how to build \nrpclib\n.\n\n\n\n\nDependencies\n\n\nrpclib\n is completely self-contained, i.e. you don't need to install any extra libraries to use it. The library does use third-party code, but it is hidden both during compilation and linking (i.e. it means you don't need to worry about linking against those same libraries).\n\n\n\n\nTip\n\n\nSee the \nInternals\n documentation for details on how \nrpclib\n handles its dependencies.\n\n\n\n\nSetting up your environment\n\n\nIn order to use \nrpclib\n in your projects, you will need to have it built and stored somewhere on your system. Place the \nrpclib\n headers into your include path, and link the static library with your executable. The exact process of that depends on your compiler and/or IDE.\n\n\nWhere to go from here\n\n\nNow that you have an environment where you can compile and link programs with \nrpclib\n, either\ncheck out the \nPrimer\n for a step-by-step tutorial or the \nCookbook\n, if you prefer short examples with minimal instructions.", 
            "title": "Getting started"
        }, 
        {
            "location": "/gettingstarted/#what-you-need", 
            "text": "", 
            "title": "What you need"
        }, 
        {
            "location": "/gettingstarted/#compiler", 
            "text": "rpclib  is compatible with C++11, but it's also able to take advantage of C++14 if the compiler\nsupports it. At the moment, the oldest versions of the major compilers that are known to work\nare the following:   g++ 4.8  clang++ 3.7  MSVC 2015 Update 3   Newer versions of these compilers are expected to work, of course.  Since C++11 support was introduced, it might be possible to compile rpclib with even older compilers.\nIf it builds and the unit tests run without an error then it should be fine to use (please report older compilers\nthat do compile but produce failing unit tests to the issue tracker!)", 
            "title": "Compiler"
        }, 
        {
            "location": "/gettingstarted/#tools", 
            "text": "In addition to a capable compiler, you will need:   CMake 3.x  And either  GNU make, or  Ninja, or  MSBuild/Visual Studio (on Microsoft Windows).", 
            "title": "Tools"
        }, 
        {
            "location": "/gettingstarted/#the-library", 
            "text": "There are various release packages available for the most popular systems and ideally you should install one of those. If there is no suitable package for your system or you simply prefer to build from source, take a look at the  Compiling  chapter.   Info  rpclib  uses CMake and has a very conventional build process. If you know how to build a CMake-based library, you know how to build  rpclib .", 
            "title": "The library"
        }, 
        {
            "location": "/gettingstarted/#dependencies", 
            "text": "rpclib  is completely self-contained, i.e. you don't need to install any extra libraries to use it. The library does use third-party code, but it is hidden both during compilation and linking (i.e. it means you don't need to worry about linking against those same libraries).   Tip  See the  Internals  documentation for details on how  rpclib  handles its dependencies.", 
            "title": "Dependencies"
        }, 
        {
            "location": "/gettingstarted/#setting-up-your-environment", 
            "text": "In order to use  rpclib  in your projects, you will need to have it built and stored somewhere on your system. Place the  rpclib  headers into your include path, and link the static library with your executable. The exact process of that depends on your compiler and/or IDE.", 
            "title": "Setting up your environment"
        }, 
        {
            "location": "/gettingstarted/#where-to-go-from-here", 
            "text": "Now that you have an environment where you can compile and link programs with  rpclib , either\ncheck out the  Primer  for a step-by-step tutorial or the  Cookbook , if you prefer short examples with minimal instructions.", 
            "title": "Where to go from here"
        }, 
        {
            "location": "/primer/", 
            "text": "Welcome to the Primer! This document is a tutorial introduction to \nrpclib\n for absolute beginners. If you are new to the library and prefer detailed instructions and explanation, you are in the right place. If short examples with less explanation work better for you, you might want to check out the \nCookbook\n!\n\n\nThe tutorial is sturctured as follows: in the first part, writing servers is explained with one simple and one more advanced example.  In the second part, the corresponding clients are implemented.\n\n\nPrerequisites\n\n\nKnowledge-wise, this tutorial assumes that you have an intermediate grasp of C++ and that you have an idea of what \nRPC\n (Remote Procedure Call) is.\n\n\nFor your build environment, make sure that you are able to compile and link a program with\n\nrpclib\n. The \nGetting Started\n page can help you with that.\n\n\nIntroduction\n\n\nrpclib\n is a RPC library that provides both a \nclient\n and a \nserver\n implementation. The \nserver\n allows you to expose functions of your program to be called remotely, while the \nclient\n allows you to call functions of servers. You can use the \nrpclib\n client and server in tandem (even in the same program, if you want to), but it's not a requirement.\n\n\nAs other RPC libraries, \nrpclib\n is a good candidate for inter-process communication. Also, there exist many implementations of the protocol in a large amount of languages, which makes it a possible inter-language communication bridge.\n\n\nmsgpack-RPC is the protocol that \nrpclib\n uses for dispatching and encoding calls to functions. The protocol is based on \nmsgpack\n, a fast and compact format. For details on how exactly it is structured, see the \nSpecification\n chapter.\n\n\nWriting servers\n\n\nIn the first part of this tutorial, we will learn about writing server applications. Two example\napplications will be implemented step-by-step.\n\n\nCalculator, the \"Hello World\" of RPC libraries.\n\n\nOur first server application will expose four functions: \nadd\n, \nsubtract\n, \nmultiply\n, \ndivide\n. For the sake of this example, the functions are implemented as various callable entities.\n\n\n#include\n \nrpc/server.h\n\n\n\ndouble\n \ndivide\n(\ndouble\n \na\n,\n \ndouble\n \nb\n)\n \n{\n \nreturn\n \na\n \n/\n \nb\n;\n \n}\n\n\n\nstruct\n \nsubtractor\n \n{\n\n    \ndouble\n \noperator\n()(\ndouble\n \na\n,\n \ndouble\n \nb\n)\n \n{\n \nreturn\n \na\n \n-\n \nb\n;\n \n}\n\n\n};\n\n\n\nstruct\n \nmultiplier\n \n{\n\n    \ndouble\n \nmultiply\n(\ndouble\n \na\n,\n \ndouble\n \nb\n)\n \n{\n \nreturn\n \na\n \n*\n \nb\n;\n \n}\n\n\n};\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nsubtractor\n \ns\n;\n\n    \nmultiplier\n \nm\n;\n\n    \nauto\n \nadd\n \n=\n \n[](\ndouble\n \na\n,\n \ndouble\n \nb\n)\n \n{\n \nreturn\n \na\n \n+\n \nb\n;\n \n};\n\n\n    \n// ...\n\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nNow, let's create the server:\n\n\nrpc\n::\nserver\n \nsrv\n(\n8080\n);\n\n\n\n\n\n\nThis server will listen on port 8080 (but not right away after construction - we need to \nrun\n it). Next, we \nbind\n the functors to names in order to expose them:\n\n\nsrv\n.\nbind\n(\nadd\n,\n \n[](\ndouble\n \na\n,\n \ndouble\n \nb\n)\n \n{\n \nreturn\n \na\n \n+\n \nb\n;\n \n});\n\n\nsrv\n.\nbind\n(\nsub\n,\n \ns\n);\n\n\nsrv\n.\nbind\n(\ndiv\n,\n \ndivide\n);\n\n\nsrv\n.\nbind\n(\nmul\n,\n \n[\nm\n](\ndouble\n \na\n,\n \ndouble\n \nb\n)\n \n{\n \nreturn\n \nm\n.\nmultiply\n(\na\n,\n \nb\n);\n \n});\n\n\n\n\n\n\nThese are the names that the client can use to call our functions. There is nothing stopping you from binding \ndivide\n to the name \n\"add\"\n, but it's a good practice to use names that reflect the source names. It is also possible to bind the same function to multiple names.\n\n\n\n\nInfo\n\n\nUnder the hood, each \nbind\n statement generates a compile-time a wrapper function that takes a \nmsgpack\n object, then decodes it into the real parameters of the bound function (if any) and calls the bound function. If the function has a return value the wrapper is generated so that it encodes the result as a \nmsgpack\n object which the server can send to the client in a response. More information on this mechanism can be found in the \nInternals\n chapter.\n\n\n\n\nAfter we exposed the function, we need to \nrun\n the server:\n\n\nsrv\n.\nrun\n();\n\n\n\n\n\n\nrun\n is a blocking function, but it also has a non-blocking pair called \nasync_run\n. When \nrun\n is called, the server starts listening on the port we assigned to it in its constructor, and its internal event loop will start processing the incoming requests.\n\n\nThis is now a functioning (although, in some ways, incomplete) server. The complete listing so far:\n\n\n#include\n \nrpc/server.h\n\n\n\ndouble\n \ndivide\n(\ndouble\n \na\n,\n \ndouble\n \nb\n)\n \n{\n \nreturn\n \na\n \n/\n \nb\n;\n \n}\n\n\n\nstruct\n \nsubtractor\n \n{\n\n    \ndouble\n \noperator\n()(\ndouble\n \na\n,\n \ndouble\n \nb\n)\n \n{\n \nreturn\n \na\n \n-\n \nb\n;\n \n}\n\n\n};\n\n\n\nstruct\n \nmultiplier\n \n{\n\n    \ndouble\n \nmultiply\n(\ndouble\n \na\n,\n \ndouble\n \nb\n)\n \n{\n \nreturn\n \na\n \n*\n \nb\n;\n \n}\n\n\n};\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nrpc\n::\nserver\n \nsrv\n(\n8080\n);\n\n\n    \nsubtractor\n \ns\n;\n\n    \nmultiplier\n \nm\n;\n\n\n    \nsrv\n.\nbind\n(\nadd\n,\n \n[](\ndouble\n \na\n,\n \ndouble\n \nb\n)\n \n{\n \nreturn\n \na\n \n+\n \nb\n;\n \n});\n\n    \nsrv\n.\nbind\n(\nsub\n,\n \ns\n);\n\n    \nsrv\n.\nbind\n(\ndiv\n,\n \ndivide\n);\n\n    \nsrv\n.\nbind\n(\nmul\n,\n \n[\nm\n](\ndouble\n \na\n,\n \ndouble\n \nb\n)\n \n{\n \nreturn\n \nm\n.\nmultiply\n(\na\n,\n \nb\n);\n \n});\n\n\n    \nsrv\n.\nrun\n();\n\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nIf you want, you can fire up a \nquick python script\n to test it (don't worry, we'll write a client with \nrpclib\n, too).\n\n\nResponding with errors\n\n\nThere is, however, an issue with this server. Did you spot it? Any client can easily make it crash just by calling \ndiv\n with a 0 divider (causing division by zero). What can we do about this? Well of course, we can just check the divider and \nnot\n perform the division. We still need to return \nsomething\n though:\n\n\n#include\n \nrpc/server.h\n\n\n\ndouble\n \ndivide\n(\ndouble\n \na\n,\n \ndouble\n \nb\n)\n \n{\n\n    \nif\n \n(\nb\n \n==\n \n0\n)\n \n{\n\n        \nreturn\n \n0.0\n;\n \n// \n- ugh, that\ns not very good :S\n\n    \n}\n\n    \nreturn\n \na\n \n/\n \nb\n;\n\n\n}\n\n\n\n\n\n\nThis is enough to avoid the crash, but it's fundamentally broken: division by zero does not yield zero, after all. The client gets an arbitrary result (oblivious to the fact that there was an error), which is most likely not what they want.\n\n\nLuckily, the msgpack-rpc protocol supports error signaling. We need to modify our \ndivide\n function a little bit to utilize this functionality:\n\n\n#include\n \nrpc/server.h\n\n\n#include\n \nrpc/this_handler.h\n\n\n\ndouble\n \ndivide\n(\ndouble\n \na\n,\n \ndouble\n \nb\n)\n \n{\n\n    \nif\n \n(\nb\n \n==\n \n0\n)\n \n{\n\n        \nrpc\n::\nthis_handler\n().\nrespond_error\n(\nDivision by zero\n);\n\n    \n}\n\n    \nreturn\n \na\n \n/\n \nb\n;\n\n\n}\n\n\n\n\n\n\nThis is better. The error is \nstringly-typed\n, but it's\nbetter than an arbitrary result. To amend this, we can return practically any object, such as\na tuple that contains an error code besides the message:\n\n\ndouble\n \ndivide\n(\ndouble\n \na\n,\n \ndouble\n \nb\n)\n \n{\n\n    \nif\n \n(\nb\n \n==\n \n0.0\n)\n \n{\n\n        \nrpc\n::\nthis_handler\n().\nrespond_error\n(\n\n                \nstd\n::\nmake_tuple\n(\n1\n,\n \nDivision by zero\n));\n\n    \n}\n\n    \nreturn\n \na\n \n/\n \nb\n;\n\n\n}\n\n\n\n\n\n\n\n\nInfo\n\n\nmsgpack-rpc\n does not define the structure of error objects, so making up something like this is\nperfectly fine (in fact, I'd encourage you to do this with well-defined error codes). Consider\nit part of your server interface and document accordingly.\n\n\n\n\nYou might be puzzled about why we are not returning after setting the error. The reason for this is that \nrespond_error\n throws an internal exception that is handled inside the library. (\nThis can be considered an implementation detail, but it's good to know what happens here (and it's unlikely to change\n).\n\n\nNow, with the added error handling, our server is bullet-proof. Or is it?\n\n\nWhat about \nmy\n exceptions?\n\n\nOur little calculator server is pretty stable at this point, but real-world applications often have to deal with exceptions. In general, exceptions should be handled at the library users' discretion (that is, caught on the handler level). So by default, \nrpclib\n doesn't do anything with them. If an exception leaves the handler, it is an unhandled exception and your server will crash. Yet, there are cases when you can't or don't want to handle exceptions in the handler. To facilitate this, \nrpclib\n provides a way to automatically turn exceptions into RPC errors:\n\n\nsrv\n.\nsuppress_exceptions\n(\ntrue\n);\n\n\n\n\n\n\nWith this, you can call functions that throw or throw exceptions:\n\n\ndouble\n \ndivide\n(\ndouble\n \na\n,\n \ndouble\n \nb\n)\n \n{\n\n    \nif\n \n(\nb\n \n==\n \n0\n)\n \n{\n\n        \nrpc\n::\nthis_handler\n().\nrespond_error\n(\n\n                \nstd\n::\nmake_tuple\n(\n1\n,\n \nDivision by zero\n));\n\n    \n}\n\n    \nelse\n \nif\n \n(\nb\n \n==\n \n1\n)\n \n{\n\n        \nthrow\n \nstd\n::\nruntime_error\n(\nCome on!\n);\n\n    \n}\n\n    \nthrow\n \nstd\n::\nlogic_error\n(\nWhat am I doing here?\n);\n\n\n}\n\n\n\n\n\n\nSo yes, this means that if you set \nsuppress_excpetions\n to \ntrue\n, you might as well signal errors from handlers by throwing exceptions. Be advised that \nrespond_error\n is still valid and remains the preferred way to do so (especially that it's the only way to respond with structured error objects).\n\n\nWhat exactly happens to the suppressed exception? \nrpclib\n will try to catch \nstd::exceptions\n and use their \nwhat()\n members to get a string representation which it sets as an error.\n\n\nWhat if you throw something that is not a \nstd::exception\n-descendant? First of all, shame on you. Second, \nrpclib\n will send an error message letting your clients know that you threw something that is not a \nstd::exception\n (\nshaming you in front of your clients\n). Don't do this, really.\n\n\nA more complicated server - Parallel mandelbrot-generation\n\n\nThe following example demonstrates parallel processing and binding custom data types. The server itself will have two functions: one for getting the current date and time, and one for getting a rendering of the mandelbrot set. The two functions can be called asynchronously by a client.\n\n\nUsing custom types as parameters\n\n\nAnything that msgpack can process can be used as a parameter or return value for a bound function. In order to teach msgpack about your custom types, you need to use the \nMSGPACK_DEFINE_ARRAY\n or \nMSGPACK_DEFINE_MAP\n macros.\n\n\n\n\nInfo\n\n\nThe difference between the two macros is that the array only contains the data values after each other, while the map also contains the names of the values. The latter gives more flexibility, the former is more compact.\n\n\n\n\nIn our mandelbrot example, we will want to send pixel data to the clients, so let's define a struct:\n\n\nstruct\n \npixel\n \n{\n\n    \nunsigned\n \nchar\n \nr\n,\n \ng\n,\n \nb\n;\n\n    \nMSGPACK_DEFINE_ARRAY\n(\nr\n,\n \ng\n,\n \nb\n)\n\n\n};\n\n\n\nusing\n \npixel_data\n \n=\n \nstd\n::\nvector\npixel\n;\n\n\n\n\n\n\nWe will share this definition between the client and server, so for our purposes it's best to put it in a common header.\n\n\nLike in the first example, we create the server and bind the functions we expose. This time we are using lambdas as the bound functions.\n\n\nrpc\n::\nserver\n \nsrv\n(\n8080\n);\n\n\n\nsrv\n.\nbind\n(\nget_time\n,\n \n[]()\n \n{\n\n    \ntime_t\n \nrawtime\n;\n\n    \nstruct\n \ntm\n \n*\ntimeinfo\n;\n\n    \ntime\n \n(\nrawtime\n);\n\n    \ntimeinfo\n \n=\n \nlocaltime\n(\nrawtime\n);\n\n    \nreturn\n \nasctime\n(\ntimeinfo\n);\n\n\n});\n\n\n\nsrv\n.\nbind\n(\nget_mandelbrot\n,\n \n[\n](\nint\n \nwidth\n,\n \nint\n \nheight\n)\n \n{\n\n    \npixel_data\n \ndata\n;\n\n    \nfor\n \n(\nint\n \nx\n \n=\n \n0\n;\n \nx\n \n \nwidth\n;\n \nx\n++\n)\n \n{\n\n        \nfor\n \n(\nint\n \ny\n \n=\n \n0\n;\n \ny\n \n \nheight\n;\n \ny\n++\n)\n \n{\n\n            \n// ...\n\n        \n}\n\n    \n}\n\n\n    \nreturn\n \ndata\n;\n\n\n});\n\n\n\n\n\n\nThe exact contents of these functions is not a concern for our purposes, just note that the \nget_time\n returns a value very quickly, while \nget_mandelbrot\n computes a large array of numbers for several seconds.\n\n\nRunning the server asynchrously and utilizing workers\n\n\nIn the first example, we called the blocking \nrun\n function of the server to start it. Here, we are going to use \nasync_run\n. There are two important differences.\n\n\n. \nrun\n blocks, \nasync_run\n returns after starting the server.\n. \nasync_run\n supports spawning worker threads for executing the bound functions.\n\n\nIn this example, we call it like this:\n\n\nsrv\n.\nasync_run\n(\n2\n);\n\n\n\n\n\n\nThis will spawn two worker threads in the server (so now there are three in the program, because the main thread already exists). The threads will wait until there is work to do.\n\n\n\n\nInfo\n\n\n\"Work\" is not only executing handlers. Processing network I/O is also part of the work that threads can take. You don't need an extra thread per connection though, because processing the I/O is typically not very processor-intensive.\n\n\n\n\nNow this server can take a call to \nget_mandelbrot\n, start executing it and in the meantime it can finish multiple \nget_time\n calls. The handlers are only executed by these worker threads, the main thread is free to continue.\n\n\nWriting clients\n\n\nCreating msgpack-rpc clients with \nrpclib\n happens very similarly to servers. Mirroring the server examples above, we will implement their corresponding clients.\n\n\nThe Calculator client\n\n\nThe \nclient\n object is instantiated like this:\n\n\nrpc\n::\nclient\n \nclient\n(\n127.0.0.1\n,\n \n8080\n);\n\n\n\n\n\n\nThe important difference, compared to a server, is that we also need to specify the host to connect to.\n\n\nAnother difference is that the client tries to connect to the server right away during construction (but the construction of the client is not a blocking call). The client object can be used right away:\n\n\ndouble\n \nfive\n \n=\n \nc\n.\ncall\n(\nadd\n,\n \n2\n,\n \n3\n).\nas\ndouble\n();\n\n\n\n\n\n\nLet's try and call all of the exposed functions. With a little bit of logging to the standard\noutput, the complete listing looks like this so far:\n\n\n#include\n \niostream\n\n\n\n#include\n \nrpc/client.h\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nrpc\n::\nclient\n \nc\n(\nlocalhost\n,\n \n8080\n);\n\n\n    \nstd\n::\ncout\n \n \nadd(2, 3) = \n;\n\n    \ndouble\n \nfive\n \n=\n \nc\n.\ncall\n(\nadd\n,\n \n2\n,\n \n3\n).\nas\ndouble\n();\n\n    \nstd\n::\ncout\n \n \nfive\n \n \nstd\n::\nendl\n;\n\n\n    \nstd\n::\ncout\n \n \nsub(3, 2) = \n;\n\n    \ndouble\n \none\n \n=\n \nc\n.\ncall\n(\nsub\n,\n \n3\n,\n \n2\n).\nas\ndouble\n();\n\n    \nstd\n::\ncout\n \n \none\n \n \nstd\n::\nendl\n;\n\n\n    \nstd\n::\ncout\n \n \nmul(5, 0) = \n;\n\n    \ndouble\n \nzero\n \n=\n \nc\n.\ncall\n(\nmul\n,\n \nfive\n,\n \n0\n).\nas\ndouble\n();\n\n    \nstd\n::\ncout\n \n \nzero\n \n \nstd\n::\nendl\n;\n\n\n    \nstd\n::\ncout\n \n \ndiv(3, 0) = \n;\n\n    \ndouble\n \nhmm\n \n=\n \nc\n.\ncall\n(\ndiv\n,\n \n3\n,\n \n0\n).\nas\ndouble\n();\n\n    \nstd\n::\ncout\n \n \nhmm\n \n \nstd\n::\nendl\n;\n\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nError handling\n\n\nAny request that a client makes might potentially receive an error response. In the calculator server, we decided to respond with a \ntuple\n containing an error code and a message. \nrpclib\n allows you to handle these error objects by catching \nrpc::rpc_error\n exceptions. To handle the errors the server throws, we would wrap the calls like this:\n\n\ntry\n \n{\n\n    \nstd\n::\ncout\n \n \nadd(2, 3) = \n;\n\n    \ndouble\n \nfive\n \n=\n \nc\n.\ncall\n(\nadd\n,\n \n2\n,\n \n3\n).\nas\ndouble\n();\n\n    \nstd\n::\ncout\n \n \nfive\n \n \nstd\n::\nendl\n;\n\n\n    \nstd\n::\ncout\n \n \nsub(3, 2) = \n;\n\n    \ndouble\n \none\n \n=\n \nc\n.\ncall\n(\nsub\n,\n \n3\n,\n \n2\n).\nas\ndouble\n();\n\n    \nstd\n::\ncout\n \n \none\n \n \nstd\n::\nendl\n;\n\n\n    \nstd\n::\ncout\n \n \nmul(5, 0) = \n;\n\n    \ndouble\n \nzero\n \n=\n \nc\n.\ncall\n(\nmul\n,\n \nfive\n,\n \n0\n).\nas\ndouble\n();\n\n    \nstd\n::\ncout\n \n \nzero\n \n \nstd\n::\nendl\n;\n\n\n    \nstd\n::\ncout\n \n \ndiv(3, 0) = \n;\n\n    \ndouble\n \nhmm\n \n=\n \nc\n.\ncall\n(\ndiv\n,\n \n3\n,\n \n0\n).\nas\ndouble\n();\n\n    \nstd\n::\ncout\n \n \nhmm\n \n \nstd\n::\nendl\n;\n\n\n}\n \ncatch\n \n(\nrpc\n::\nrpc_error\n \ne\n)\n \n{\n\n    \nstd\n::\ncout\n \n \nstd\n::\nendl\n \n \ne\n.\nwhat\n()\n \n \nstd\n::\nendl\n;\n\n    \nstd\n::\ncout\n \n \nin function \n \n \ne\n.\nget_function_name\n()\n \n \n: \n;\n\n\n    \nusing\n \nerr_t\n \n=\n \nstd\n::\ntuple\nint\n,\n \nstd\n::\nstring\n;\n\n    \nauto\n \nerr\n \n=\n \ne\n.\nget_error\n().\nas\nerr_t\n();\n\n    \nstd\n::\ncout\n \n \n[error \n \n \nstd\n::\nget\n0\n(\nerr\n)\n \n \n]: \n \n \nstd\n::\nget\n1\n(\nerr\n)\n\n              \n \nstd\n::\nendl\n;\n\n    \nreturn\n \n1\n;\n\n\n}\n\n\n\n\n\n\nAs you would expect, the output looks like this:\n\n\nadd(2, 3) = 5\nsub(3, 2) = 1\nmul(5, 0) = 0\ndiv(3, 0) =\nrpclib: a handler responded with an error\nin function \ndiv\n: [error 1]: Division by zero\n\n\n\n\n\nThat's pretty much all we need for the calculator client.\n\n\nThe anatomy of a \ncall\n\n\ncall\n does a couple of things:\n\n\n\n\nIf the client is not yet connected to the server, it waits until it connects (this might block until the connection is established)\n\n\nSends a \"call\" message to the server\n\n\nWaits for the response and returns it as a msgpack object - this blocks until the response is read.\n\n\n\n\nIn the example above, you can see how getting a strongly typed value from the result is done: using the \nas\n member template. This takes the msgpack object and tries to deserialize it into the type given. If that fails, you will get a \ntype_error\n.\n\n\ncall\n takes at least one parameter (the name of the function to call), and an arbitrary number and type of other paramters that are meant to be passed to the function being called. Each parameter has to be serializable by msgpack.\n\n\n\n\nTip\n\n\nSee \nmsgpack adaptors\n from the msgpack documentation for more information on serializing and deserializing custom types.\n\n\n\n\nThe Mandelbrot client\n\n\nThe client for the mandelbrot server above is interesting because we will take advantage of the multiple workers in the server. In order to do that, instead of \ncall\n we are going to use \nasync_call\n.\n\n\nasync_call\n is very similar to \ncall\n, but it does not wait for the response. Instead, it will return a \nfuture\n, allowing us to continue our program flow and retrieve the result later (which the server can compute in the meantime).\n\n\nrpc\n::\nclient\n \nc\n(\n127.0.0.1\n,\n \n8080\n);\n\n\n\n// this returns immediately:\n\n\nauto\n \nresult_obj\n \n=\n \nc\n.\nasync_call\n(\nget_mandelbrot\n,\n \nwidth\n,\n \nheight\n);\n\n\n\n// we can now call another function and wait for its result:\n\n\nauto\n \ncurrent_time\n \n=\n \nc\n.\ncall\n(\nget_time\n).\nas\nstd\n::\nstring\n();\n\n\n\n// ... after some time, retrieve the result (optionally wait for it)\n\n\nauto\n \nresult\n \n=\n \nresult_obj\n.\nget\n().\nas\npixel_data\n();\n\n\n\n\n\n\nThe call to \nget_time\n can be performed with \ncall\n (no need for \nasync_call\n), because the other call is running on a different worker.\n\n\n\n\nInfo\n\n\nWhat would happen if our server only had one worker thread?\n We would get the same output, but with more delay: The server would only start processing the \nget_time\n call after it finished executing and writing the response of \nget_mandelbrot\n. Essentially, a single-threaded server works in a \"queue\" fashion. The same thing would happen if the server was simple under heavy load.\n\n\n\n\nAsync servers vs. async clients vs. parallel execution\n\n\nDoes the asynchonous nature of \nasync_call\n depend on the server or the load of the server then? No, it does not. It's important to realize that \nasync_call\n is still asynchronous even if the server does not execute requests in parallel. If there are multiple clients connected to the server, their requests are processed in a more queued manner (still two requests processed at the same time).\n\n\n\n\nTip\n\n\nrpclib\n uses a simple convention: \nfoo\n is a synchronous call, \nasync_foo\n is asynchronous. This conventions was adapted from Asio. The latter only means that the call returns \"immediately\" (or rather, very quickly and without finishing all of the work).\n\n\n\n\nThe two worker threads in the mandelbrot server can serve two clients in parallel. Or two calls of the same client, which happens in the example. In order to be able to send two requests in an interleaved fashion, we first use \nasync_call\n which allows the control flow of the client to continue.\n\n\nWhere to go from here\n\n\nThe \nCookbook\n features most (if not all) intended use cases of rpclib - it's a great\nplace to continue.\n\n\nIf you are interested in the internal design of \nrpclib\n, take a look at the \nInternals\n\npage.", 
            "title": "Primer"
        }, 
        {
            "location": "/primer/#prerequisites", 
            "text": "Knowledge-wise, this tutorial assumes that you have an intermediate grasp of C++ and that you have an idea of what  RPC  (Remote Procedure Call) is.  For your build environment, make sure that you are able to compile and link a program with rpclib . The  Getting Started  page can help you with that.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/primer/#introduction", 
            "text": "rpclib  is a RPC library that provides both a  client  and a  server  implementation. The  server  allows you to expose functions of your program to be called remotely, while the  client  allows you to call functions of servers. You can use the  rpclib  client and server in tandem (even in the same program, if you want to), but it's not a requirement.  As other RPC libraries,  rpclib  is a good candidate for inter-process communication. Also, there exist many implementations of the protocol in a large amount of languages, which makes it a possible inter-language communication bridge.  msgpack-RPC is the protocol that  rpclib  uses for dispatching and encoding calls to functions. The protocol is based on  msgpack , a fast and compact format. For details on how exactly it is structured, see the  Specification  chapter.", 
            "title": "Introduction"
        }, 
        {
            "location": "/primer/#writing-servers", 
            "text": "In the first part of this tutorial, we will learn about writing server applications. Two example\napplications will be implemented step-by-step.", 
            "title": "Writing servers"
        }, 
        {
            "location": "/primer/#calculator-the-hello-world-of-rpc-libraries", 
            "text": "Our first server application will expose four functions:  add ,  subtract ,  multiply ,  divide . For the sake of this example, the functions are implemented as various callable entities.  #include   rpc/server.h  double   divide ( double   a ,   double   b )   {   return   a   /   b ;   }  struct   subtractor   { \n     double   operator ()( double   a ,   double   b )   {   return   a   -   b ;   }  };  struct   multiplier   { \n     double   multiply ( double   a ,   double   b )   {   return   a   *   b ;   }  };  int   main ()   { \n     subtractor   s ; \n     multiplier   m ; \n     auto   add   =   []( double   a ,   double   b )   {   return   a   +   b ;   }; \n\n     // ... \n\n     return   0 ;  }   Now, let's create the server:  rpc :: server   srv ( 8080 );   This server will listen on port 8080 (but not right away after construction - we need to  run  it). Next, we  bind  the functors to names in order to expose them:  srv . bind ( add ,   []( double   a ,   double   b )   {   return   a   +   b ;   });  srv . bind ( sub ,   s );  srv . bind ( div ,   divide );  srv . bind ( mul ,   [ m ]( double   a ,   double   b )   {   return   m . multiply ( a ,   b );   });   These are the names that the client can use to call our functions. There is nothing stopping you from binding  divide  to the name  \"add\" , but it's a good practice to use names that reflect the source names. It is also possible to bind the same function to multiple names.   Info  Under the hood, each  bind  statement generates a compile-time a wrapper function that takes a  msgpack  object, then decodes it into the real parameters of the bound function (if any) and calls the bound function. If the function has a return value the wrapper is generated so that it encodes the result as a  msgpack  object which the server can send to the client in a response. More information on this mechanism can be found in the  Internals  chapter.   After we exposed the function, we need to  run  the server:  srv . run ();   run  is a blocking function, but it also has a non-blocking pair called  async_run . When  run  is called, the server starts listening on the port we assigned to it in its constructor, and its internal event loop will start processing the incoming requests.  This is now a functioning (although, in some ways, incomplete) server. The complete listing so far:  #include   rpc/server.h  double   divide ( double   a ,   double   b )   {   return   a   /   b ;   }  struct   subtractor   { \n     double   operator ()( double   a ,   double   b )   {   return   a   -   b ;   }  };  struct   multiplier   { \n     double   multiply ( double   a ,   double   b )   {   return   a   *   b ;   }  };  int   main ()   { \n     rpc :: server   srv ( 8080 ); \n\n     subtractor   s ; \n     multiplier   m ; \n\n     srv . bind ( add ,   []( double   a ,   double   b )   {   return   a   +   b ;   }); \n     srv . bind ( sub ,   s ); \n     srv . bind ( div ,   divide ); \n     srv . bind ( mul ,   [ m ]( double   a ,   double   b )   {   return   m . multiply ( a ,   b );   }); \n\n     srv . run (); \n\n     return   0 ;  }   If you want, you can fire up a  quick python script  to test it (don't worry, we'll write a client with  rpclib , too).", 
            "title": "Calculator, the \"Hello World\" of RPC libraries."
        }, 
        {
            "location": "/primer/#responding-with-errors", 
            "text": "There is, however, an issue with this server. Did you spot it? Any client can easily make it crash just by calling  div  with a 0 divider (causing division by zero). What can we do about this? Well of course, we can just check the divider and  not  perform the division. We still need to return  something  though:  #include   rpc/server.h  double   divide ( double   a ,   double   b )   { \n     if   ( b   ==   0 )   { \n         return   0.0 ;   //  - ugh, that s not very good :S \n     } \n     return   a   /   b ;  }   This is enough to avoid the crash, but it's fundamentally broken: division by zero does not yield zero, after all. The client gets an arbitrary result (oblivious to the fact that there was an error), which is most likely not what they want.  Luckily, the msgpack-rpc protocol supports error signaling. We need to modify our  divide  function a little bit to utilize this functionality:  #include   rpc/server.h  #include   rpc/this_handler.h  double   divide ( double   a ,   double   b )   { \n     if   ( b   ==   0 )   { \n         rpc :: this_handler (). respond_error ( Division by zero ); \n     } \n     return   a   /   b ;  }   This is better. The error is  stringly-typed , but it's\nbetter than an arbitrary result. To amend this, we can return practically any object, such as\na tuple that contains an error code besides the message:  double   divide ( double   a ,   double   b )   { \n     if   ( b   ==   0.0 )   { \n         rpc :: this_handler (). respond_error ( \n                 std :: make_tuple ( 1 ,   Division by zero )); \n     } \n     return   a   /   b ;  }    Info  msgpack-rpc  does not define the structure of error objects, so making up something like this is\nperfectly fine (in fact, I'd encourage you to do this with well-defined error codes). Consider\nit part of your server interface and document accordingly.   You might be puzzled about why we are not returning after setting the error. The reason for this is that  respond_error  throws an internal exception that is handled inside the library. ( This can be considered an implementation detail, but it's good to know what happens here (and it's unlikely to change ).  Now, with the added error handling, our server is bullet-proof. Or is it?", 
            "title": "Responding with errors"
        }, 
        {
            "location": "/primer/#what-about-my-exceptions", 
            "text": "Our little calculator server is pretty stable at this point, but real-world applications often have to deal with exceptions. In general, exceptions should be handled at the library users' discretion (that is, caught on the handler level). So by default,  rpclib  doesn't do anything with them. If an exception leaves the handler, it is an unhandled exception and your server will crash. Yet, there are cases when you can't or don't want to handle exceptions in the handler. To facilitate this,  rpclib  provides a way to automatically turn exceptions into RPC errors:  srv . suppress_exceptions ( true );   With this, you can call functions that throw or throw exceptions:  double   divide ( double   a ,   double   b )   { \n     if   ( b   ==   0 )   { \n         rpc :: this_handler (). respond_error ( \n                 std :: make_tuple ( 1 ,   Division by zero )); \n     } \n     else   if   ( b   ==   1 )   { \n         throw   std :: runtime_error ( Come on! ); \n     } \n     throw   std :: logic_error ( What am I doing here? );  }   So yes, this means that if you set  suppress_excpetions  to  true , you might as well signal errors from handlers by throwing exceptions. Be advised that  respond_error  is still valid and remains the preferred way to do so (especially that it's the only way to respond with structured error objects).  What exactly happens to the suppressed exception?  rpclib  will try to catch  std::exceptions  and use their  what()  members to get a string representation which it sets as an error.  What if you throw something that is not a  std::exception -descendant? First of all, shame on you. Second,  rpclib  will send an error message letting your clients know that you threw something that is not a  std::exception  ( shaming you in front of your clients ). Don't do this, really.", 
            "title": "What about my exceptions?"
        }, 
        {
            "location": "/primer/#a-more-complicated-server-parallel-mandelbrot-generation", 
            "text": "The following example demonstrates parallel processing and binding custom data types. The server itself will have two functions: one for getting the current date and time, and one for getting a rendering of the mandelbrot set. The two functions can be called asynchronously by a client.", 
            "title": "A more complicated server - Parallel mandelbrot-generation"
        }, 
        {
            "location": "/primer/#using-custom-types-as-parameters", 
            "text": "Anything that msgpack can process can be used as a parameter or return value for a bound function. In order to teach msgpack about your custom types, you need to use the  MSGPACK_DEFINE_ARRAY  or  MSGPACK_DEFINE_MAP  macros.   Info  The difference between the two macros is that the array only contains the data values after each other, while the map also contains the names of the values. The latter gives more flexibility, the former is more compact.   In our mandelbrot example, we will want to send pixel data to the clients, so let's define a struct:  struct   pixel   { \n     unsigned   char   r ,   g ,   b ; \n     MSGPACK_DEFINE_ARRAY ( r ,   g ,   b )  };  using   pixel_data   =   std :: vector pixel ;   We will share this definition between the client and server, so for our purposes it's best to put it in a common header.  Like in the first example, we create the server and bind the functions we expose. This time we are using lambdas as the bound functions.  rpc :: server   srv ( 8080 );  srv . bind ( get_time ,   []()   { \n     time_t   rawtime ; \n     struct   tm   * timeinfo ; \n     time   ( rawtime ); \n     timeinfo   =   localtime ( rawtime ); \n     return   asctime ( timeinfo );  });  srv . bind ( get_mandelbrot ,   [ ]( int   width ,   int   height )   { \n     pixel_data   data ; \n     for   ( int   x   =   0 ;   x     width ;   x ++ )   { \n         for   ( int   y   =   0 ;   y     height ;   y ++ )   { \n             // ... \n         } \n     } \n\n     return   data ;  });   The exact contents of these functions is not a concern for our purposes, just note that the  get_time  returns a value very quickly, while  get_mandelbrot  computes a large array of numbers for several seconds.", 
            "title": "Using custom types as parameters"
        }, 
        {
            "location": "/primer/#running-the-server-asynchrously-and-utilizing-workers", 
            "text": "In the first example, we called the blocking  run  function of the server to start it. Here, we are going to use  async_run . There are two important differences.  .  run  blocks,  async_run  returns after starting the server.\n.  async_run  supports spawning worker threads for executing the bound functions.  In this example, we call it like this:  srv . async_run ( 2 );   This will spawn two worker threads in the server (so now there are three in the program, because the main thread already exists). The threads will wait until there is work to do.   Info  \"Work\" is not only executing handlers. Processing network I/O is also part of the work that threads can take. You don't need an extra thread per connection though, because processing the I/O is typically not very processor-intensive.   Now this server can take a call to  get_mandelbrot , start executing it and in the meantime it can finish multiple  get_time  calls. The handlers are only executed by these worker threads, the main thread is free to continue.", 
            "title": "Running the server asynchrously and utilizing workers"
        }, 
        {
            "location": "/primer/#writing-clients", 
            "text": "Creating msgpack-rpc clients with  rpclib  happens very similarly to servers. Mirroring the server examples above, we will implement their corresponding clients.", 
            "title": "Writing clients"
        }, 
        {
            "location": "/primer/#the-calculator-client", 
            "text": "The  client  object is instantiated like this:  rpc :: client   client ( 127.0.0.1 ,   8080 );   The important difference, compared to a server, is that we also need to specify the host to connect to.  Another difference is that the client tries to connect to the server right away during construction (but the construction of the client is not a blocking call). The client object can be used right away:  double   five   =   c . call ( add ,   2 ,   3 ). as double ();   Let's try and call all of the exposed functions. With a little bit of logging to the standard\noutput, the complete listing looks like this so far:  #include   iostream  #include   rpc/client.h  int   main ()   { \n     rpc :: client   c ( localhost ,   8080 ); \n\n     std :: cout     add(2, 3) =  ; \n     double   five   =   c . call ( add ,   2 ,   3 ). as double (); \n     std :: cout     five     std :: endl ; \n\n     std :: cout     sub(3, 2) =  ; \n     double   one   =   c . call ( sub ,   3 ,   2 ). as double (); \n     std :: cout     one     std :: endl ; \n\n     std :: cout     mul(5, 0) =  ; \n     double   zero   =   c . call ( mul ,   five ,   0 ). as double (); \n     std :: cout     zero     std :: endl ; \n\n     std :: cout     div(3, 0) =  ; \n     double   hmm   =   c . call ( div ,   3 ,   0 ). as double (); \n     std :: cout     hmm     std :: endl ; \n\n     return   0 ;  }", 
            "title": "The Calculator client"
        }, 
        {
            "location": "/primer/#error-handling", 
            "text": "Any request that a client makes might potentially receive an error response. In the calculator server, we decided to respond with a  tuple  containing an error code and a message.  rpclib  allows you to handle these error objects by catching  rpc::rpc_error  exceptions. To handle the errors the server throws, we would wrap the calls like this:  try   { \n     std :: cout     add(2, 3) =  ; \n     double   five   =   c . call ( add ,   2 ,   3 ). as double (); \n     std :: cout     five     std :: endl ; \n\n     std :: cout     sub(3, 2) =  ; \n     double   one   =   c . call ( sub ,   3 ,   2 ). as double (); \n     std :: cout     one     std :: endl ; \n\n     std :: cout     mul(5, 0) =  ; \n     double   zero   =   c . call ( mul ,   five ,   0 ). as double (); \n     std :: cout     zero     std :: endl ; \n\n     std :: cout     div(3, 0) =  ; \n     double   hmm   =   c . call ( div ,   3 ,   0 ). as double (); \n     std :: cout     hmm     std :: endl ;  }   catch   ( rpc :: rpc_error   e )   { \n     std :: cout     std :: endl     e . what ()     std :: endl ; \n     std :: cout     in function      e . get_function_name ()     :  ; \n\n     using   err_t   =   std :: tuple int ,   std :: string ; \n     auto   err   =   e . get_error (). as err_t (); \n     std :: cout     [error      std :: get 0 ( err )     ]:      std :: get 1 ( err ) \n                 std :: endl ; \n     return   1 ;  }   As you would expect, the output looks like this:  add(2, 3) = 5\nsub(3, 2) = 1\nmul(5, 0) = 0\ndiv(3, 0) =\nrpclib: a handler responded with an error\nin function  div : [error 1]: Division by zero  That's pretty much all we need for the calculator client.", 
            "title": "Error handling"
        }, 
        {
            "location": "/primer/#the-anatomy-of-a-call", 
            "text": "call  does a couple of things:   If the client is not yet connected to the server, it waits until it connects (this might block until the connection is established)  Sends a \"call\" message to the server  Waits for the response and returns it as a msgpack object - this blocks until the response is read.   In the example above, you can see how getting a strongly typed value from the result is done: using the  as  member template. This takes the msgpack object and tries to deserialize it into the type given. If that fails, you will get a  type_error .  call  takes at least one parameter (the name of the function to call), and an arbitrary number and type of other paramters that are meant to be passed to the function being called. Each parameter has to be serializable by msgpack.   Tip  See  msgpack adaptors  from the msgpack documentation for more information on serializing and deserializing custom types.", 
            "title": "The anatomy of a call"
        }, 
        {
            "location": "/primer/#the-mandelbrot-client", 
            "text": "The client for the mandelbrot server above is interesting because we will take advantage of the multiple workers in the server. In order to do that, instead of  call  we are going to use  async_call .  async_call  is very similar to  call , but it does not wait for the response. Instead, it will return a  future , allowing us to continue our program flow and retrieve the result later (which the server can compute in the meantime).  rpc :: client   c ( 127.0.0.1 ,   8080 );  // this returns immediately:  auto   result_obj   =   c . async_call ( get_mandelbrot ,   width ,   height );  // we can now call another function and wait for its result:  auto   current_time   =   c . call ( get_time ). as std :: string ();  // ... after some time, retrieve the result (optionally wait for it)  auto   result   =   result_obj . get (). as pixel_data ();   The call to  get_time  can be performed with  call  (no need for  async_call ), because the other call is running on a different worker.   Info  What would happen if our server only had one worker thread?  We would get the same output, but with more delay: The server would only start processing the  get_time  call after it finished executing and writing the response of  get_mandelbrot . Essentially, a single-threaded server works in a \"queue\" fashion. The same thing would happen if the server was simple under heavy load.", 
            "title": "The Mandelbrot client"
        }, 
        {
            "location": "/primer/#async-servers-vs-async-clients-vs-parallel-execution", 
            "text": "Does the asynchonous nature of  async_call  depend on the server or the load of the server then? No, it does not. It's important to realize that  async_call  is still asynchronous even if the server does not execute requests in parallel. If there are multiple clients connected to the server, their requests are processed in a more queued manner (still two requests processed at the same time).   Tip  rpclib  uses a simple convention:  foo  is a synchronous call,  async_foo  is asynchronous. This conventions was adapted from Asio. The latter only means that the call returns \"immediately\" (or rather, very quickly and without finishing all of the work).   The two worker threads in the mandelbrot server can serve two clients in parallel. Or two calls of the same client, which happens in the example. In order to be able to send two requests in an interleaved fashion, we first use  async_call  which allows the control flow of the client to continue.", 
            "title": "Async servers vs. async clients vs. parallel execution"
        }, 
        {
            "location": "/primer/#where-to-go-from-here", 
            "text": "The  Cookbook  features most (if not all) intended use cases of rpclib - it's a great\nplace to continue.  If you are interested in the internal design of  rpclib , take a look at the  Internals \npage.", 
            "title": "Where to go from here"
        }, 
        {
            "location": "/cookbook/", 
            "text": "Welcome to the Cookbook! This is a collection of short examples that allows you to quickly learn\nthe ins and outs of \nrpclib\n. This guide is written in the spirit of \"less talk and more code\" (it's mostly only the titles, but also look out for the comments, they contain important information).\nIf you prefer detailed instructions and explanation, you might want to start with the\n\nPrimer\n.\n\n\nServer examples\n\n\nCreating a server\n\n\n#include\n \nrpc/server.h\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nrpc\n::\nserver\n \nsrv\n(\n8080\n);\n \n// listen on TCP port 8080\n\n\n    \nsrv\n.\nrun\n();\n \n// blocking call\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nBinding (exposing) free functions\n\n\n#include\n \nrpc/server.h\n\n\n#include\n \niostream\n\n\n\nvoid\n \nfoo\n()\n \n{\n\n    \nstd\n::\ncout\n \n \nHey, I\nm a free function.\n \n \nstd\n::\nendl\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nrpc\n::\nserver\n \nsrv\n(\n8080\n);\n \n// listen on TCP port 8080\n\n\n    \nsrv\n.\nbind\n(\nfoo\n,\n \nfoo\n);\n\n\n    \nsrv\n.\nrun\n();\n \n// blocking call, handlers run on this thread.\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nBinding lambdas\n\n\n#include\n \nrpc/server.h\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nrpc\n::\nserver\n \nsrv\n(\n8080\n);\n \n// listen on TCP port 8080\n\n\n    \nsrv\n.\nbind\n(\nhl3\n,\n \n[]()\n \n{\n\n        \nstd\n::\ncout\n \n \nHey, I\nm a lambda!\n \n \nstd\n::\nendl\n;\n\n    \n});\n\n\n    \nsrv\n.\nrun\n();\n \n// blocking call\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nBinding member functions\n\n\nConsider this class:\n\n\nclass\n \nfoo_class\n \n{\n\n\npublic\n:\n\n    \nvoid\n \nquaz\n()\n \n{\n\n        \nstd\n::\ncout\n \n \nHey, I\nm a member function!\n \n \nstd\n::\nendl\n;\n\n    \n}\n\n\n};\n\n\n\n\n\n\nVersion 1: Binding through a lambda (preferred)\n\n\n#include\n \nrpc/server.h\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nrpc\n::\nserver\n \nsrv\n(\n8080\n);\n \n// listen on TCP port 8080\n\n    \nfoo_class\n \nfoo_obj\n;\n\n\n    \nsrv\n.\nbind\n(\nquaz\n,\n \n[\nfoo_obj\n](){\n \nfoo_obj\n.\nquaz\n();\n \n});\n\n\n    \nsrv\n.\nrun\n();\n \n// blocking call\n\n\n    \n// NOTE: you have to make sure that the lifetime of foo_obj\n\n    \n// exceeds that of the server.\n\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nVersion 2: using \nstd::bind\n\n\n#include\n \nfunctional\n\n\n\n#include\n \nrpc/server.h\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nrpc\n::\nserver\n \nsrv\n(\n8080\n);\n \n// listen on TCP port 8080\n\n    \nfoo_class\n \nfoo_obj\n;\n\n\n    \nstd\n::\nfunction\nvoid\n()\n \nfunctor\n{\nstd\n::\nbind\n(\nfoo_class\n::\nquaz\n,\n \nfoo_obj\n)};\n\n\n    \nsrv\n.\nbind\n(\nquaz\n,\n \nfunctor\n);\n\n\n    \nsrv\n.\nrun\n();\n \n// blocking call\n\n\n    \n// NOTE: you have to make sure that the lifetime of foo_obj\n\n    \n// exceeds that of the server.\n\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nMultiple worker threads\n\n\n#include\n \nrpc/server.h\n\n\n#include\n \niostream\n\n\n\nvoid\n \nfoo\n()\n \n{\n\n    \nstd\n::\ncout\n \n \nHey, I\nm a free function.\n \n \nstd\n::\nendl\n;\n\n\n}\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nrpc\n::\nserver\n \nsrv\n(\n8080\n);\n \n// listen on TCP port 8080\n\n\n    \nsrv\n.\nbind\n(\nfoo\n,\n \nfoo\n);\n\n\n    \nconstexpr\n \nsize_t\n \nthread_count\n \n=\n \n8\n;\n\n\n    \nsrv\n.\nasync_run\n(\nthread_count\n);\n \n// non-blocking call, handlers execute on one of the workers\n\n\n    \nstd\n::\ncin\n.\nignore\n();\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nBinding using custom types\n\n\n#include\n \nrpc/server.h\n\n\n\nstruct\n \ncustom_type\n \n{\n\n    \nint\n \nx\n;\n\n    \ndouble\n \ny\n;\n\n    \nstd\n::\nstring\n \nstr\n;\n\n    \nMSGPACK_DEFINE_ARRAY\n(\nx\n,\n \ny\n,\n \nstr\n);\n \n// or MSGPACK_DEFINE_MAP\n\n\n};\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nrpc\n::\nserver\n \nsrv\n(\n8080\n);\n \n// listen on TCP port 8080\n\n\n    \nsrv\n.\nbind\n(\ncool_function\n,\n \n[](\ncustom_type\n \nconst\n \nc\n)\n \n{\n\n        \nstd\n::\ncout\n \n \nc = { \n \n \nc\n.\nx\n \n \n, \n\n                  \n \nc\n.\ny\n \n \n, \n \n \nc\n.\nstr\n \n \n}\n \n \nstd\n::\nendl\n;\n\n    \n});\n\n\n    \nsrv\n.\nrun\n();\n \n// blocking call\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nResponding with errors\n\n\n#include\n \nrpc/server.h\n\n\n#include\n \nrpc/this_handler.h\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nrpc\n::\nserver\n \nsrv\n(\n8080\n);\n \n// listen on TCP port 8080\n\n\n    \nsrv\n.\nbind\n(\nerror\n,\n \n[]()\n \n{\n\n        \nauto\n \nerr_obj\n \n=\n \nstd\n::\nmake_tuple\n(\n13\n,\n \nErrors are arbitrary objects\n);\n\n        \nrpc\n::\nthis_handler\n().\nrespond_error\n(\nerr_obj\n);\n\n    \n});\n\n\n    \nsrv\n.\nrun\n();\n \n// blocking call\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nResponding with arbitrary objects\n\n\nEven though C++ isn't, \nmsgpack-rpc\n is very lenient on types. Your client might be implemented in\na dynamic language.\n\n\n#include\n \nrpc/server.h\n\n\n#include\n \nrpc/this_handler.h\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nrpc\n::\nserver\n \nsrv\n(\n8080\n);\n \n// listen on TCP port 8080\n\n\n    \nsrv\n.\nbind\n(\noh\n,\n \n[](\nbool\n \nquirky\n)\n \n-\n \nstd\n::\nstring\n \n{\n\n        \nif\n \n(\nquirky\n)\n \n{\n\n            \nrpc\n::\nthis_handler\n().\nrespond\n(\n5\n);\n\n        \n}\n\n        \nreturn\n \nI\nm not quirky.\n;\n\n    \n});\n\n\n    \nsrv\n.\nrun\n();\n \n// blocking call\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nDisabling response\n\n\nThis prevents the server from ever writing a response to a particular call.\n\n\n#include\n \nrpc/server.h\n\n\n#include\n \nrpc/this_handler.h\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nrpc\n::\nserver\n \nsrv\n(\n8080\n);\n \n// listen on TCP port 8080\n\n\n    \nsrv\n.\nbind\n(\nplz_respond\n,\n \n[](\nbool\n \nnice\n)\n \n{\n\n        \nif\n \n(\nnice\n)\n \n{\n\n            \nrpc\n::\nthis_handler\n().\ndisable_response\n();\n\n        \n}\n\n        \nreturn\n \nok\n;\n\n    \n});\n\n\n    \nsrv\n.\nrun\n();\n \n// blocking call\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nExiting a session\n\n\nA session represents a client connection on the server. All ongoing writes and reads are completed first.\n\n\n#include\n \nrpc/server.h\n\n\n#include\n \nrpc/this_session.h\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nrpc\n::\nserver\n \nsrv\n(\n8080\n);\n \n// listen on TCP port 8080\n\n\n    \nsrv\n.\nbind\n(\nexit\n,\n \n[]()\n \n{\n\n        \nrpc\n::\nthis_session\n().\npost_exit\n();\n \n// post exit to the queue\n\n    \n});\n\n\n    \nsrv\n.\nrun\n();\n \n// blocking call\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\npost_exit\n will add exiting the session as a work item to the queue. This means that exiting is\nnot instantenous. The TCP connection will be closed gracefully.\n\n\nStopping a server\n\n\nTo gracefully stop all sessions on the server. All ongoing writes and reads are completed first.\n\n\n#include\n \nrpc/server.h\n\n\n#include\n \nrpc/this_server.h\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nrpc\n::\nserver\n \nsrv\n(\n8080\n);\n \n// listen on TCP port 8080\n\n\n    \nsrv\n.\nbind\n(\nstop_server\n,\n \n[]()\n \n{\n\n        \nrpc\n::\nthis_server\n().\nstop\n();\n\n    \n});\n\n\n    \nsrv\n.\nrun\n();\n \n// blocking call\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nClient examples\n\n\nCreating a client\n\n\n#include\n \nrpc/client.h\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nrpc\n::\nclient\n \nc\n(\n127.0.0.1\n,\n \n8080\n);\n\n\n    \n// client initiates async connection upon creation\n\n    \nreturn\n \n0\n;\n\n\n    \n// destructor of client disconnects\n\n\n}\n\n\n\n\n\n\nCalling functions\n\n\n#include\n \nrpc/client.h\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nrpc\n::\nclient\n \nc\n(\n127.0.0.1\n,\n \n8080\n);\n\n\n    \n// client initiates async connection upon creation\n\n\n    \n// call blocks until:\n\n    \n// - connection is established\n\n    \n// - result is read\n\n    \nc\n.\ncall\n(\nfoo\n,\n \n2\n,\n \n3.3\n,\n \nstr\n);\n\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nGetting return values\n\n\n#include\n \nrpc/client.h\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nrpc\n::\nclient\n \nc\n(\n127.0.0.1\n,\n \n8080\n);\n\n    \nint\n \na\n \n=\n \nc\n.\ncall\n(\nadd\n,\n \n2\n,\n \n3\n).\nas\nint\n();\n\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nCalling functions asynchronously\n\n\n#include\n \nrpc/client.h\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nrpc\n::\nclient\n \nc\n(\n127.0.0.1\n,\n \n8080\n);\n\n\n    \nauto\n \na_future\n \n=\n \nc\n.\nasync_call\n(\nadd\n,\n \n2\n,\n \n3\n);\n \n// non-blocking, returns std::future\n\n\n    \nstd\n::\ncout\n \n \nI can do something here immediately\n \n \nstd\n::\nendl\n;\n\n\n    \nint\n \na\n \n=\n \na_future\n.\nget\n().\nas\nint\n();\n \n// possibly blocks if the result is not yet available\n\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nQuerying the connection state\n\n\n#include\n \nrpc/client.h\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nrpc\n::\nclient\n \nc\n(\n127.0.0.1\n,\n \n8080\n);\n\n    \nclient\n::\nconnection_state\n \ncs\n \n=\n \nc\n.\nget_connection_state\n();\n\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nApplying a timeout to synchronous calls\n\n\n#include\n \nrpc/client.h\n\n\n\nint\n \nmain\n()\n \n{\n\n    \nrpc\n::\nclient\n \nc\n(\n127.0.0.1\n,\n \n8080\n);\n\n\n    \ntry\n \n{\n\n        \n// default timeout is 5000 milliseconds\n\n        \nconst\n \nuint64_t\n \nshort_timeout\n \n=\n \n50\n;\n\n        \nclient\n.\nset_timeout\n(\nshort_timeout\n);\n\n        \nclient\n.\ncall\n(\nsleep\n,\n \nshort_timeout\n \n+\n \n10\n);\n\n    \n}\n \ncatch\n \n(\nrpc\n::\ntimeout\n \nt\n)\n \n{\n\n        \n// will display a message like\n\n        \n// rpc::timeout: Timeout of 50ms while calling RPC function \nsleep\n\n        \nstd\n::\ncout\n \n \nt\n.\nwhat\n()\n \n \nstd\n::\nendl\n;\n\n    \n}\n\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nWhere to go from here\n\n\nIf you want to know even more about \nrpclib\n, look behind the abstractions in the \nInternals\n chapter which explains the internal workings and design decisions.", 
            "title": "Cookbook"
        }, 
        {
            "location": "/cookbook/#server-examples", 
            "text": "", 
            "title": "Server examples"
        }, 
        {
            "location": "/cookbook/#creating-a-server", 
            "text": "#include   rpc/server.h  int   main ()   { \n     rpc :: server   srv ( 8080 );   // listen on TCP port 8080 \n\n     srv . run ();   // blocking call \n     return   0 ;  }", 
            "title": "Creating a server"
        }, 
        {
            "location": "/cookbook/#binding-exposing-free-functions", 
            "text": "#include   rpc/server.h  #include   iostream  void   foo ()   { \n     std :: cout     Hey, I m a free function.     std :: endl ;  }  int   main ()   { \n     rpc :: server   srv ( 8080 );   // listen on TCP port 8080 \n\n     srv . bind ( foo ,   foo ); \n\n     srv . run ();   // blocking call, handlers run on this thread. \n     return   0 ;  }", 
            "title": "Binding (exposing) free functions"
        }, 
        {
            "location": "/cookbook/#binding-lambdas", 
            "text": "#include   rpc/server.h  int   main ()   { \n     rpc :: server   srv ( 8080 );   // listen on TCP port 8080 \n\n     srv . bind ( hl3 ,   []()   { \n         std :: cout     Hey, I m a lambda!     std :: endl ; \n     }); \n\n     srv . run ();   // blocking call \n     return   0 ;  }", 
            "title": "Binding lambdas"
        }, 
        {
            "location": "/cookbook/#binding-member-functions", 
            "text": "Consider this class:  class   foo_class   {  public : \n     void   quaz ()   { \n         std :: cout     Hey, I m a member function!     std :: endl ; \n     }  };", 
            "title": "Binding member functions"
        }, 
        {
            "location": "/cookbook/#version-1-binding-through-a-lambda-preferred", 
            "text": "#include   rpc/server.h  int   main ()   { \n     rpc :: server   srv ( 8080 );   // listen on TCP port 8080 \n     foo_class   foo_obj ; \n\n     srv . bind ( quaz ,   [ foo_obj ](){   foo_obj . quaz ();   }); \n\n     srv . run ();   // blocking call \n\n     // NOTE: you have to make sure that the lifetime of foo_obj \n     // exceeds that of the server. \n\n     return   0 ;  }", 
            "title": "Version 1: Binding through a lambda (preferred)"
        }, 
        {
            "location": "/cookbook/#version-2-using-stdbind", 
            "text": "#include   functional  #include   rpc/server.h  int   main ()   { \n     rpc :: server   srv ( 8080 );   // listen on TCP port 8080 \n     foo_class   foo_obj ; \n\n     std :: function void ()   functor { std :: bind ( foo_class :: quaz ,   foo_obj )}; \n\n     srv . bind ( quaz ,   functor ); \n\n     srv . run ();   // blocking call \n\n     // NOTE: you have to make sure that the lifetime of foo_obj \n     // exceeds that of the server. \n\n     return   0 ;  }", 
            "title": "Version 2: using std::bind"
        }, 
        {
            "location": "/cookbook/#multiple-worker-threads", 
            "text": "#include   rpc/server.h  #include   iostream  void   foo ()   { \n     std :: cout     Hey, I m a free function.     std :: endl ;  }  int   main ()   { \n     rpc :: server   srv ( 8080 );   // listen on TCP port 8080 \n\n     srv . bind ( foo ,   foo ); \n\n     constexpr   size_t   thread_count   =   8 ; \n\n     srv . async_run ( thread_count );   // non-blocking call, handlers execute on one of the workers \n\n     std :: cin . ignore (); \n     return   0 ;  }", 
            "title": "Multiple worker threads"
        }, 
        {
            "location": "/cookbook/#binding-using-custom-types", 
            "text": "#include   rpc/server.h  struct   custom_type   { \n     int   x ; \n     double   y ; \n     std :: string   str ; \n     MSGPACK_DEFINE_ARRAY ( x ,   y ,   str );   // or MSGPACK_DEFINE_MAP  };  int   main ()   { \n     rpc :: server   srv ( 8080 );   // listen on TCP port 8080 \n\n     srv . bind ( cool_function ,   []( custom_type   const   c )   { \n         std :: cout     c = {      c . x     ,  \n                     c . y     ,      c . str     }     std :: endl ; \n     }); \n\n     srv . run ();   // blocking call \n     return   0 ;  }", 
            "title": "Binding using custom types"
        }, 
        {
            "location": "/cookbook/#responding-with-errors", 
            "text": "#include   rpc/server.h  #include   rpc/this_handler.h  int   main ()   { \n     rpc :: server   srv ( 8080 );   // listen on TCP port 8080 \n\n     srv . bind ( error ,   []()   { \n         auto   err_obj   =   std :: make_tuple ( 13 ,   Errors are arbitrary objects ); \n         rpc :: this_handler (). respond_error ( err_obj ); \n     }); \n\n     srv . run ();   // blocking call \n     return   0 ;  }", 
            "title": "Responding with errors"
        }, 
        {
            "location": "/cookbook/#responding-with-arbitrary-objects", 
            "text": "Even though C++ isn't,  msgpack-rpc  is very lenient on types. Your client might be implemented in\na dynamic language.  #include   rpc/server.h  #include   rpc/this_handler.h  int   main ()   { \n     rpc :: server   srv ( 8080 );   // listen on TCP port 8080 \n\n     srv . bind ( oh ,   []( bool   quirky )   -   std :: string   { \n         if   ( quirky )   { \n             rpc :: this_handler (). respond ( 5 ); \n         } \n         return   I m not quirky. ; \n     }); \n\n     srv . run ();   // blocking call \n     return   0 ;  }", 
            "title": "Responding with arbitrary objects"
        }, 
        {
            "location": "/cookbook/#disabling-response", 
            "text": "This prevents the server from ever writing a response to a particular call.  #include   rpc/server.h  #include   rpc/this_handler.h  int   main ()   { \n     rpc :: server   srv ( 8080 );   // listen on TCP port 8080 \n\n     srv . bind ( plz_respond ,   []( bool   nice )   { \n         if   ( nice )   { \n             rpc :: this_handler (). disable_response (); \n         } \n         return   ok ; \n     }); \n\n     srv . run ();   // blocking call \n     return   0 ;  }", 
            "title": "Disabling response"
        }, 
        {
            "location": "/cookbook/#exiting-a-session", 
            "text": "A session represents a client connection on the server. All ongoing writes and reads are completed first.  #include   rpc/server.h  #include   rpc/this_session.h  int   main ()   { \n     rpc :: server   srv ( 8080 );   // listen on TCP port 8080 \n\n     srv . bind ( exit ,   []()   { \n         rpc :: this_session (). post_exit ();   // post exit to the queue \n     }); \n\n     srv . run ();   // blocking call \n     return   0 ;  }   post_exit  will add exiting the session as a work item to the queue. This means that exiting is\nnot instantenous. The TCP connection will be closed gracefully.", 
            "title": "Exiting a session"
        }, 
        {
            "location": "/cookbook/#stopping-a-server", 
            "text": "To gracefully stop all sessions on the server. All ongoing writes and reads are completed first.  #include   rpc/server.h  #include   rpc/this_server.h  int   main ()   { \n     rpc :: server   srv ( 8080 );   // listen on TCP port 8080 \n\n     srv . bind ( stop_server ,   []()   { \n         rpc :: this_server (). stop (); \n     }); \n\n     srv . run ();   // blocking call \n     return   0 ;  }", 
            "title": "Stopping a server"
        }, 
        {
            "location": "/cookbook/#client-examples", 
            "text": "", 
            "title": "Client examples"
        }, 
        {
            "location": "/cookbook/#creating-a-client", 
            "text": "#include   rpc/client.h  int   main ()   { \n     rpc :: client   c ( 127.0.0.1 ,   8080 ); \n\n     // client initiates async connection upon creation \n     return   0 ; \n\n     // destructor of client disconnects  }", 
            "title": "Creating a client"
        }, 
        {
            "location": "/cookbook/#calling-functions", 
            "text": "#include   rpc/client.h  int   main ()   { \n     rpc :: client   c ( 127.0.0.1 ,   8080 ); \n\n     // client initiates async connection upon creation \n\n     // call blocks until: \n     // - connection is established \n     // - result is read \n     c . call ( foo ,   2 ,   3.3 ,   str ); \n\n     return   0 ;  }", 
            "title": "Calling functions"
        }, 
        {
            "location": "/cookbook/#getting-return-values", 
            "text": "#include   rpc/client.h  int   main ()   { \n     rpc :: client   c ( 127.0.0.1 ,   8080 ); \n     int   a   =   c . call ( add ,   2 ,   3 ). as int (); \n\n     return   0 ;  }", 
            "title": "Getting return values"
        }, 
        {
            "location": "/cookbook/#calling-functions-asynchronously", 
            "text": "#include   rpc/client.h  int   main ()   { \n     rpc :: client   c ( 127.0.0.1 ,   8080 ); \n\n     auto   a_future   =   c . async_call ( add ,   2 ,   3 );   // non-blocking, returns std::future \n\n     std :: cout     I can do something here immediately     std :: endl ; \n\n     int   a   =   a_future . get (). as int ();   // possibly blocks if the result is not yet available \n\n     return   0 ;  }", 
            "title": "Calling functions asynchronously"
        }, 
        {
            "location": "/cookbook/#querying-the-connection-state", 
            "text": "#include   rpc/client.h  int   main ()   { \n     rpc :: client   c ( 127.0.0.1 ,   8080 ); \n     client :: connection_state   cs   =   c . get_connection_state (); \n\n     return   0 ;  }", 
            "title": "Querying the connection state"
        }, 
        {
            "location": "/cookbook/#applying-a-timeout-to-synchronous-calls", 
            "text": "#include   rpc/client.h  int   main ()   { \n     rpc :: client   c ( 127.0.0.1 ,   8080 ); \n\n     try   { \n         // default timeout is 5000 milliseconds \n         const   uint64_t   short_timeout   =   50 ; \n         client . set_timeout ( short_timeout ); \n         client . call ( sleep ,   short_timeout   +   10 ); \n     }   catch   ( rpc :: timeout   t )   { \n         // will display a message like \n         // rpc::timeout: Timeout of 50ms while calling RPC function  sleep \n         std :: cout     t . what ()     std :: endl ; \n     } \n\n     return   0 ;  }", 
            "title": "Applying a timeout to synchronous calls"
        }, 
        {
            "location": "/cookbook/#where-to-go-from-here", 
            "text": "If you want to know even more about  rpclib , look behind the abstractions in the  Internals  chapter which explains the internal workings and design decisions.", 
            "title": "Where to go from here"
        }, 
        {
            "location": "/glossary/", 
            "text": "This is a collection of terms used in the documentation and API of rpclib.\n\n\nServer\n\n\nA program that acts as an RPC endpoint receiving calls.\n\n\nClient\n\n\nA program that connects to Servers and calls their bound functions.\n\n\nBinding\n\n\nExposing a functor of the Server with a name.\n\n\nHandler\n\n\nA bound functor.\n\n\nFunction\n\n\nThe documentation sometimes uses the terms function and functor interchangeably. In these cases,\nboth refer to \"things that can be called\"\n\n\nWorker\n\n\nA thread that performes work in the Server.", 
            "title": "Glossary"
        }, 
        {
            "location": "/glossary/#server", 
            "text": "A program that acts as an RPC endpoint receiving calls.", 
            "title": "Server"
        }, 
        {
            "location": "/glossary/#client", 
            "text": "A program that connects to Servers and calls their bound functions.", 
            "title": "Client"
        }, 
        {
            "location": "/glossary/#binding", 
            "text": "Exposing a functor of the Server with a name.", 
            "title": "Binding"
        }, 
        {
            "location": "/glossary/#handler", 
            "text": "A bound functor.", 
            "title": "Handler"
        }, 
        {
            "location": "/glossary/#function", 
            "text": "The documentation sometimes uses the terms function and functor interchangeably. In these cases,\nboth refer to \"things that can be called\"", 
            "title": "Function"
        }, 
        {
            "location": "/glossary/#worker", 
            "text": "A thread that performes work in the Server.", 
            "title": "Worker"
        }, 
        {
            "location": "/compiling/", 
            "text": "Compiling \nrpclib\n is a fairly normal and unsurprising experience if you have used cmake-based projects. This document details the advanced building options as well as building the documentation which you might find useful if you want to reproduce everything locally.\n\n\nDefault configuration\n\n\nThe default configuration is the one intended for end-users. If you want to hack on \nrpclib\n, you might be interested in some of the Advanced options.\n\n\nCompiling\n\n\nThis includes most (all?) Linux distributions, cygwin and Windows. Building \nrpclib\n is very similar to other cmake-based projects:\n\n\ngit clone git@github.com:rpclib/rpclib.git\ncd rpclib\nmkdir build\ncd build\ncmake ..\ncmake --build .\n\n\n\n\n\nAnd that's it. If all goes well, your build output will be in the \noutput\n directory.\n\n\nAdvanced options\n\n\nThere are some compilation options that affect the build output. These options can be set using ccmake, cmake-gui or on the cmake command line.\n\n\n\n\n\n\n\n\nName\n\n\nDefault value\n\n\nUsage\n\n\n\n\n\n\n\n\n\n\nRPCLIB_BUILD_TESTS\n\n\nOFF\n\n\nBuilds the unit tests of the library. You might want to turn this on if you are using an unreleased version.\n\n\n\n\n\n\nRPCLIB_GENERATE_COMPDB\n\n\nOFF\n\n\nGenerates a json compilation database for use with clang-based tools (such as clang-tidy, YCM etc.)\n\n\n\n\n\n\nRPCLIB_BUILD_EXAMPLES\n\n\nON\n\n\nBuilds the collection of example programs that demonstrate the features of \nrpclib\n.\n\n\n\n\n\n\nRPCLIB_ENABLE_LOGGING\n\n\nOFF\n\n\nEnables the internal logging of \nrpclib\n. This slightly affects performance. Currently the logging is not very configurable (for example, everything goes to stdout), but there are plans to make it easier to integrate with your application. Use this feature for debugging purposes.\n\n\n\n\n\n\nRPCLIB_ENABLE_COVERAGE\n\n\nOFF\n\n\nThis enables passing the code coverage generation flag when building with g++. It is used on Travis to provide coverage monitoring in tandem with Coveralls.io.\n\n\n\n\n\n\nRPCLIB_FORCE_M64\n\n\nOFF\n\n\nForce -m64 for g++ and clang++. Your build tools must support cross-compilation if this is not your native environment.\n\n\n\n\n\n\nRPCLIB_FORCE_M32\n\n\nOFF\n\n\nForce -m32 for g++ and clang++. Your build tools must support cross-compilation if this is not your native environment.\n\n\n\n\n\n\nRPCLIB_EXTRA_BUILD_FLAGS\n\n\n\"\"\n\n\nUse this to pass extra flags to rpclib for building, such as \n-fPIC\n. Please note that I don't normally test and build with such flags", 
            "title": "Compiling"
        }, 
        {
            "location": "/compiling/#default-configuration", 
            "text": "The default configuration is the one intended for end-users. If you want to hack on  rpclib , you might be interested in some of the Advanced options.", 
            "title": "Default configuration"
        }, 
        {
            "location": "/compiling/#compiling", 
            "text": "This includes most (all?) Linux distributions, cygwin and Windows. Building  rpclib  is very similar to other cmake-based projects:  git clone git@github.com:rpclib/rpclib.git\ncd rpclib\nmkdir build\ncd build\ncmake ..\ncmake --build .  And that's it. If all goes well, your build output will be in the  output  directory.", 
            "title": "Compiling"
        }, 
        {
            "location": "/compiling/#advanced-options", 
            "text": "There are some compilation options that affect the build output. These options can be set using ccmake, cmake-gui or on the cmake command line.     Name  Default value  Usage      RPCLIB_BUILD_TESTS  OFF  Builds the unit tests of the library. You might want to turn this on if you are using an unreleased version.    RPCLIB_GENERATE_COMPDB  OFF  Generates a json compilation database for use with clang-based tools (such as clang-tidy, YCM etc.)    RPCLIB_BUILD_EXAMPLES  ON  Builds the collection of example programs that demonstrate the features of  rpclib .    RPCLIB_ENABLE_LOGGING  OFF  Enables the internal logging of  rpclib . This slightly affects performance. Currently the logging is not very configurable (for example, everything goes to stdout), but there are plans to make it easier to integrate with your application. Use this feature for debugging purposes.    RPCLIB_ENABLE_COVERAGE  OFF  This enables passing the code coverage generation flag when building with g++. It is used on Travis to provide coverage monitoring in tandem with Coveralls.io.    RPCLIB_FORCE_M64  OFF  Force -m64 for g++ and clang++. Your build tools must support cross-compilation if this is not your native environment.    RPCLIB_FORCE_M32  OFF  Force -m32 for g++ and clang++. Your build tools must support cross-compilation if this is not your native environment.    RPCLIB_EXTRA_BUILD_FLAGS  \"\"  Use this to pass extra flags to rpclib for building, such as  -fPIC . Please note that I don't normally test and build with such flags", 
            "title": "Advanced options"
        }, 
        {
            "location": "/internals/", 
            "text": "This chapter describes the internal design of \nrpclib\n and provides some insight into the\nengineering tradeoffs considered.\n\n\nDependencies of \nrpclib\n\n\nrpclib\n is self-contained, but it does use third party code. These are the following libraries:\n\n\n\n\nasio\n (used for networking and async capabilities)\n\n\nfmtlib\n (used for string formatting in log and exception messages)\n\n\nmsgpack\n (used for encoding and decoding the protocol)\n\n\n\n\nThese dependencies are stored inside the repository of \nrpclib\n, but they are hidden both during\ncompilation and linking. This is achieved by using the pimpl pattern and changing the names of the\nnamespaces in their source files (apart from \nmsgpack\n, none of the dependencies are visible in the\nheaders even).\n\n\nThis means that as a user, you don't have to worry about linker problems if you integrate \nrpclib\n\ninto your project; and you don't need to gather its dependencies. This reduces friction. The tradeoff\nis that the size of your binary will increase if you use one of these dependencies in your project\noutside \nrpclib\n.\n\n\n\n\nInfo\n\n\nHow can I compile \nrpclib\n using dependencies outside its repository?\n While not officially\nsupported, it's possible that you will want to link to a system-installed \nasio\n because you\nare using it in your application anyway and want to avoid code bloat. To do this, delete the\nlibrary from the dependencies subfolder of the repository, and define \nRPCLIB_ASIO\n as \nasio\n\n(or \nboost::asio\n). This will cause \nrpclib\n to find the system-wide installed \nasio\n and use\nthe namespace name provided. You might also need to change some of the preprocessor definitions\nin the CMakeLists.txt if you want to use the boost-flavored asio, not the standalone one.\n\n\n\n\nThe internals of the server\n\n\nThe dispatcher\n\n\nrpclib\n maintains a registry of exposed functions in a \ndispatcher\n. The dispatcher is a class with tfunction templates and this is the part which pulls in most of the template metaprogramming in the library. The primary purpose of the metaprogramming is to generate wrappers that can manage calling an arbitrary functor from a msgpack-encoded message; then encode the result of the function (if any) in msgpack.\n\n\nThe generated wrappers have a uniform signature (\ndispatcher::adaptor_type\n) which allows storing\nthem in a map. The dispatching is performed by looking up the right functor by name.\n\n\nThe server loop\n\n\nThe call to \nserver::run\n starts an \nasio\n-loop. Everything that the server does is performed in\nthis loop. This includes not only executing the handlers, but also parsing the input and writing\nthe output. \nasync_run\n will spawn multiple worker threads that all \nrun\n the loop. Thanks to the\ngreat design of \nasio\n, this makes them act like a thread pool, i.e. waiting in line to take the\nnext available work item. This scales pretty well for networked applications.\n\n\nthis_handler\n, \nthis_session\n, \nthis_server\n\n\nThe server provides the above objects as a means of interacting with the library. Their\nimplementation relies on the realization that one thread executes at most one handler at any time;\nso \nthread_local\n objects are accessible both by the handler and the server loop. The server may\nset properties of these objects that the handler can query; and likewise, the handler can also set\nproperties that the server can query.\n\n\nThe internals of the client\n\n\nThe client is fundamentally asynchronous in nature, even though this might not be readily apparent\non the surface. The reasone for this is that responses from the server are not required to arrive\nright away, and responses to multiple requests may come in any order.\n\n\nTo address this, the client maintains a registry of ongoing calls. A \"call\" refers to\na \nstd::promise\n holding a \nmsgpack::object_handle\n, which is the future result of the call. When\nthe client reads a response, it will look up the promise and set the value.\n\n\nOn the public interface, \nasync_call\n returns a future that is bound to this promise. User code can\nwait for the result using this future.\n\n\ncall\n is simply implemented as a call to \nasync_call\n and waiting for the result right away.\n\n\nHow and why the pimpl pattern is used\n\n\nrpclib\n uses a variant of the \nfast pimpl idiom\n. The reason for\nthis is that one of the goals of the library is to provide a dependable rpc solution for projects\nand make an effort to be easily upgrade-able when new versions come out. This is also one of the\nreasons why the library is not header-only.\n\n\nInstead of a \nunique_ptr\n for the pimpl pointer, the library uses a pointer-like class which stores\nits data in a \nstd::aligned_storage\n. This increases the data locality during the calls and reduces\ndynamic allocation. The tradeoff is that the size of the storage is fixed, so adding extra data in an update is only possible with some bounds (the sizes used are a bit bigger than needed, so there is some room to do this without breaking binary compatibility).\n\n\nWhere to go from here\n\n\nAs a user, there isn't much else to learn about this library. However, if you are interested, you may\nwant to check out the \ncontribution guidelines\n, the \nissue tracker\n, and \nroadmap\n and start hacking on \nrpclib\n!", 
            "title": "Internals"
        }, 
        {
            "location": "/internals/#dependencies-of-rpclib", 
            "text": "rpclib  is self-contained, but it does use third party code. These are the following libraries:   asio  (used for networking and async capabilities)  fmtlib  (used for string formatting in log and exception messages)  msgpack  (used for encoding and decoding the protocol)   These dependencies are stored inside the repository of  rpclib , but they are hidden both during\ncompilation and linking. This is achieved by using the pimpl pattern and changing the names of the\nnamespaces in their source files (apart from  msgpack , none of the dependencies are visible in the\nheaders even).  This means that as a user, you don't have to worry about linker problems if you integrate  rpclib \ninto your project; and you don't need to gather its dependencies. This reduces friction. The tradeoff\nis that the size of your binary will increase if you use one of these dependencies in your project\noutside  rpclib .   Info  How can I compile  rpclib  using dependencies outside its repository?  While not officially\nsupported, it's possible that you will want to link to a system-installed  asio  because you\nare using it in your application anyway and want to avoid code bloat. To do this, delete the\nlibrary from the dependencies subfolder of the repository, and define  RPCLIB_ASIO  as  asio \n(or  boost::asio ). This will cause  rpclib  to find the system-wide installed  asio  and use\nthe namespace name provided. You might also need to change some of the preprocessor definitions\nin the CMakeLists.txt if you want to use the boost-flavored asio, not the standalone one.", 
            "title": "Dependencies of rpclib"
        }, 
        {
            "location": "/internals/#the-internals-of-the-server", 
            "text": "", 
            "title": "The internals of the server"
        }, 
        {
            "location": "/internals/#the-dispatcher", 
            "text": "rpclib  maintains a registry of exposed functions in a  dispatcher . The dispatcher is a class with tfunction templates and this is the part which pulls in most of the template metaprogramming in the library. The primary purpose of the metaprogramming is to generate wrappers that can manage calling an arbitrary functor from a msgpack-encoded message; then encode the result of the function (if any) in msgpack.  The generated wrappers have a uniform signature ( dispatcher::adaptor_type ) which allows storing\nthem in a map. The dispatching is performed by looking up the right functor by name.", 
            "title": "The dispatcher"
        }, 
        {
            "location": "/internals/#the-server-loop", 
            "text": "The call to  server::run  starts an  asio -loop. Everything that the server does is performed in\nthis loop. This includes not only executing the handlers, but also parsing the input and writing\nthe output.  async_run  will spawn multiple worker threads that all  run  the loop. Thanks to the\ngreat design of  asio , this makes them act like a thread pool, i.e. waiting in line to take the\nnext available work item. This scales pretty well for networked applications.", 
            "title": "The server loop"
        }, 
        {
            "location": "/internals/#this_handler-this_session-this_server", 
            "text": "The server provides the above objects as a means of interacting with the library. Their\nimplementation relies on the realization that one thread executes at most one handler at any time;\nso  thread_local  objects are accessible both by the handler and the server loop. The server may\nset properties of these objects that the handler can query; and likewise, the handler can also set\nproperties that the server can query.", 
            "title": "this_handler, this_session, this_server"
        }, 
        {
            "location": "/internals/#the-internals-of-the-client", 
            "text": "The client is fundamentally asynchronous in nature, even though this might not be readily apparent\non the surface. The reasone for this is that responses from the server are not required to arrive\nright away, and responses to multiple requests may come in any order.  To address this, the client maintains a registry of ongoing calls. A \"call\" refers to\na  std::promise  holding a  msgpack::object_handle , which is the future result of the call. When\nthe client reads a response, it will look up the promise and set the value.  On the public interface,  async_call  returns a future that is bound to this promise. User code can\nwait for the result using this future.  call  is simply implemented as a call to  async_call  and waiting for the result right away.", 
            "title": "The internals of the client"
        }, 
        {
            "location": "/internals/#how-and-why-the-pimpl-pattern-is-used", 
            "text": "rpclib  uses a variant of the  fast pimpl idiom . The reason for\nthis is that one of the goals of the library is to provide a dependable rpc solution for projects\nand make an effort to be easily upgrade-able when new versions come out. This is also one of the\nreasons why the library is not header-only.  Instead of a  unique_ptr  for the pimpl pointer, the library uses a pointer-like class which stores\nits data in a  std::aligned_storage . This increases the data locality during the calls and reduces\ndynamic allocation. The tradeoff is that the size of the storage is fixed, so adding extra data in an update is only possible with some bounds (the sizes used are a bit bigger than needed, so there is some room to do this without breaking binary compatibility).", 
            "title": "How and why the pimpl pattern is used"
        }, 
        {
            "location": "/internals/#where-to-go-from-here", 
            "text": "As a user, there isn't much else to learn about this library. However, if you are interested, you may\nwant to check out the  contribution guidelines , the  issue tracker , and  roadmap  and start hacking on  rpclib !", 
            "title": "Where to go from here"
        }, 
        {
            "location": "/spec/", 
            "text": "MessagePack-RPC Protocol specification\n\n\nThis specification was copied from \nhttps://github.com/msgpack-rpc/msgpack-rpc/blob/master/spec.md\n\n(without the \"sales pitch\" part).\n\n\nThe protocol consists of a request message and the corresponding response message or a notification message (without a response). The server must send a response message in reply with the request message.\n\n\nRequest message\n\n\nThe request message is a four-element array, shown below.\n\n\n[type, msgid, method, params]\n\n\n\n\n\ntype\n\n\nMust be zero (integer). Zero means that this message is the request message.\n\n\nmsgid\n\n\nThe 32-bit unsigned integer number. This number is used as a sequence number. The server replies with a requested msgid.\n\n\nmethod\n\n\nThe string, which represents the method name to call.\n\n\nparams\n\n\nThe array of the function arguments. The elements of this array are arbitrary objects. If the\nfunction takes no arguments, this is an empty array (not \nnil\n).\n\n\nResponse message\n\n\nThe response message is a four-element array, shown below.\n\n\n[type, msgid, error, result]\n\n\n\n\n\ntype\n\n\nMust be one (integer). One means that this message is the response message.\n\n\nmsgid\n\n\nThe 32-bit unsigned integer number. This corresponds to the msgid of the request message.\n\n\nerror\n\n\nIf the method is executed correctly, this field should be \nnil\n. If the error occurred at the server-side, then this field is an arbitrary object which represents the error.\n\n\nresult\n\n\nAn arbitrary object, which represents the returned result of the function. If an error occurred, this field should be \nnil\n.\n\n\nNotification message\n\n\nThe notification message is a three-element array, shown below.\n\n\n[type, method, params]\n\n\n\n\n\ntype\n\n\nMust be two (integer). Two means that this message is a notification message.\n\n\nmethod\n\n\nThe string, which represents the method name to call.\n\n\nparams\n\n\nThe array of the function arguments. The elements of this array are arbitrary objects. If the\nfunction takes no arguments, this is an empty array (not \nnil\n).\n\n\nThe order of responses\n\n\nThe server implementations don't have to send the responses in the order of receiveing the requests. If they receive the multiple messages, they may reply in any order.\n\n\nClient implementation details\n\n\nThere are some client features which a client library should implement.\n\n\nSynchronous calls\n\n\nThe client is blocked until the RPC is finished.\n\n\nClient\n \nclient\n \n=\n \nnew\n \nClient\n(\nlocalhost\n,\n \n1985\n);\n\n\nObject\n \nresult\n \n=\n \nclient\n.\ncall\n(\nmethod_name\n,\n \narg1\n,\n \narg2\n,\n \narg3\n);\n\n\n\n\n\n\nAsynchronous calls\n\n\nThe following figure shows how asynchronous call works.\n\n\nThe the call function returns a \nfuture\n object immediately.\n\n\nClient\n \nclient\n \n=\n \nnew\n \nClient\n(\nlocalhost\n,\n \n1985\n);\n\n\nFuture\n \nfuture\n \n=\n \nclient\n.\nasyncCall\n(\nmethod_name\n,\n \narg1\n,\n \narg2\n,\n \narg3\n);\n\n\nfuture\n.\njoin\n();\n\n\nObject\n \nresult\n \n=\n \nfuture\n.\ngetResult\n();\n\n\n\n\n\n\nClient\n \nclient\n \n=\n \nnew\n \nClient\n(...);\n\n\nFuture\n \nf1\n \n=\n \nclient\n.\nasyncCall\n(\nmethod1\n);\n\n\nFuture\n \nf2\n \n=\n \nclient\n.\nasyncCall\n(\nmethod2\n);\n\n\nf1\n.\njoin\n();\n\n\nf2\n.\njoin\n();\n\n\n\n\n\n\nMultiple transports\n\n\nThe implementation should support multiple transports like TCP, UDP, UNIX domain socket if possible.", 
            "title": "Specification"
        }, 
        {
            "location": "/spec/#messagepack-rpc-protocol-specification", 
            "text": "This specification was copied from  https://github.com/msgpack-rpc/msgpack-rpc/blob/master/spec.md \n(without the \"sales pitch\" part).  The protocol consists of a request message and the corresponding response message or a notification message (without a response). The server must send a response message in reply with the request message.", 
            "title": "MessagePack-RPC Protocol specification"
        }, 
        {
            "location": "/spec/#request-message", 
            "text": "The request message is a four-element array, shown below.  [type, msgid, method, params]", 
            "title": "Request message"
        }, 
        {
            "location": "/spec/#type", 
            "text": "Must be zero (integer). Zero means that this message is the request message.", 
            "title": "type"
        }, 
        {
            "location": "/spec/#msgid", 
            "text": "The 32-bit unsigned integer number. This number is used as a sequence number. The server replies with a requested msgid.", 
            "title": "msgid"
        }, 
        {
            "location": "/spec/#method", 
            "text": "The string, which represents the method name to call.", 
            "title": "method"
        }, 
        {
            "location": "/spec/#params", 
            "text": "The array of the function arguments. The elements of this array are arbitrary objects. If the\nfunction takes no arguments, this is an empty array (not  nil ).", 
            "title": "params"
        }, 
        {
            "location": "/spec/#response-message", 
            "text": "The response message is a four-element array, shown below.  [type, msgid, error, result]", 
            "title": "Response message"
        }, 
        {
            "location": "/spec/#type_1", 
            "text": "Must be one (integer). One means that this message is the response message.", 
            "title": "type"
        }, 
        {
            "location": "/spec/#msgid_1", 
            "text": "The 32-bit unsigned integer number. This corresponds to the msgid of the request message.", 
            "title": "msgid"
        }, 
        {
            "location": "/spec/#error", 
            "text": "If the method is executed correctly, this field should be  nil . If the error occurred at the server-side, then this field is an arbitrary object which represents the error.", 
            "title": "error"
        }, 
        {
            "location": "/spec/#result", 
            "text": "An arbitrary object, which represents the returned result of the function. If an error occurred, this field should be  nil .", 
            "title": "result"
        }, 
        {
            "location": "/spec/#notification-message", 
            "text": "The notification message is a three-element array, shown below.  [type, method, params]", 
            "title": "Notification message"
        }, 
        {
            "location": "/spec/#type_2", 
            "text": "Must be two (integer). Two means that this message is a notification message.", 
            "title": "type"
        }, 
        {
            "location": "/spec/#method_1", 
            "text": "The string, which represents the method name to call.", 
            "title": "method"
        }, 
        {
            "location": "/spec/#params_1", 
            "text": "The array of the function arguments. The elements of this array are arbitrary objects. If the\nfunction takes no arguments, this is an empty array (not  nil ).", 
            "title": "params"
        }, 
        {
            "location": "/spec/#the-order-of-responses", 
            "text": "The server implementations don't have to send the responses in the order of receiveing the requests. If they receive the multiple messages, they may reply in any order.", 
            "title": "The order of responses"
        }, 
        {
            "location": "/spec/#client-implementation-details", 
            "text": "There are some client features which a client library should implement.", 
            "title": "Client implementation details"
        }, 
        {
            "location": "/spec/#synchronous-calls", 
            "text": "The client is blocked until the RPC is finished.  Client   client   =   new   Client ( localhost ,   1985 );  Object   result   =   client . call ( method_name ,   arg1 ,   arg2 ,   arg3 );", 
            "title": "Synchronous calls"
        }, 
        {
            "location": "/spec/#asynchronous-calls", 
            "text": "The following figure shows how asynchronous call works.  The the call function returns a  future  object immediately.  Client   client   =   new   Client ( localhost ,   1985 );  Future   future   =   client . asyncCall ( method_name ,   arg1 ,   arg2 ,   arg3 );  future . join ();  Object   result   =   future . getResult ();   Client   client   =   new   Client (...);  Future   f1   =   client . asyncCall ( method1 );  Future   f2   =   client . asyncCall ( method2 );  f1 . join ();  f2 . join ();", 
            "title": "Asynchronous calls"
        }, 
        {
            "location": "/spec/#multiple-transports", 
            "text": "The implementation should support multiple transports like TCP, UDP, UNIX domain socket if possible.", 
            "title": "Multiple transports"
        }, 
        {
            "location": "/roadmap/", 
            "text": "This chapter is about features that are planned in the upcoming versions of \nrpclib\n. Keep in mind\nthat this serves merely as a draft of current ideas; something being here is not guaranteed to ever\nbe implmented; and anything that's \nnot\n here can be implemented at any time.\n\n\nSupport different transports\n\n\nThe library is currently TCP-only. It should be possible to use domain pipes/windows pipes which\nare useful for fast IPC. UDP can be added as well, although I'm not sure how conformant that would\nbe with msgpack-rpc. Implementing transports might be exposed to the users of the library as well.\n\n\nSupport different protocols\n\n\nThere are protocols that are structured very similarly to \nmsgpack-rpc\n, such as \njson-rpc\n.\nConsidering this, it won't be terribly hard to refactor the wrapper-generation to allow\nconsuming and producing different protocols.\n\n\nSupport framed-msgpack-rpc\n\n\nnodejs uses a variation of msgpack-rpc, called framed-msgpack-rpc. It's the same protocol, but the\nmessages are delimited with their sizes which allows avoiding reallocations for large messages.\n\n\nCode generator\n\n\nUsing libclang, it's fairly easy to parse a C++ header file. With attributes provided by the\nlibrary, it should be possible to mark a class for RPC exposure and the code generator should take\ncare of creating a specialized server for the class (or client for an interface).\n\n\nSupport IDLs of other RPC libraries\n\n\nApache Thrift, gRPC, etc. have IDLs that describe a service. \nrpclib\n should provide tools to parse\nthese IDLs to allow using \nrpclib\n as a drop-in replacement.", 
            "title": "Roadmap"
        }, 
        {
            "location": "/roadmap/#support-different-transports", 
            "text": "The library is currently TCP-only. It should be possible to use domain pipes/windows pipes which\nare useful for fast IPC. UDP can be added as well, although I'm not sure how conformant that would\nbe with msgpack-rpc. Implementing transports might be exposed to the users of the library as well.", 
            "title": "Support different transports"
        }, 
        {
            "location": "/roadmap/#support-different-protocols", 
            "text": "There are protocols that are structured very similarly to  msgpack-rpc , such as  json-rpc .\nConsidering this, it won't be terribly hard to refactor the wrapper-generation to allow\nconsuming and producing different protocols.", 
            "title": "Support different protocols"
        }, 
        {
            "location": "/roadmap/#support-framed-msgpack-rpc", 
            "text": "nodejs uses a variation of msgpack-rpc, called framed-msgpack-rpc. It's the same protocol, but the\nmessages are delimited with their sizes which allows avoiding reallocations for large messages.", 
            "title": "Support framed-msgpack-rpc"
        }, 
        {
            "location": "/roadmap/#code-generator", 
            "text": "Using libclang, it's fairly easy to parse a C++ header file. With attributes provided by the\nlibrary, it should be possible to mark a class for RPC exposure and the code generator should take\ncare of creating a specialized server for the class (or client for an interface).", 
            "title": "Code generator"
        }, 
        {
            "location": "/roadmap/#support-idls-of-other-rpc-libraries", 
            "text": "Apache Thrift, gRPC, etc. have IDLs that describe a service.  rpclib  should provide tools to parse\nthese IDLs to allow using  rpclib  as a drop-in replacement.", 
            "title": "Support IDLs of other RPC libraries"
        }, 
        {
            "location": "/contributing/", 
            "text": "This project is MIT-licensed and the development is open. All contributions are welcome. This\ndocument provides information on why, how and what to contribute.\n\n\nWhy contribute\n\n\nAt the moment, this project is an approachable, intermediate-advanced level C++ project. If you contribute code, you may deepen your knowledge in these areas:\n\n\n\n\nRPC clients and servers\n\n\nNetworking (through asio), TCP\n\n\nScalable architecture\n\n\nAsync programming\n\n\nTemplate metaprogramming * Modern C++ (C++14 and beyond) * Google Test and Google Mock\n\n\nTravis CI \n Appveyor\n\n\nContinous delivery\n\n\nCMake\n\n\n\n\nI've never contributed to open source, can I try here?\n\n\nAbsolutely! First-time contributors are very much welcome in this project. Having your pull request\naccepted by a project is a great accomplishment. Even if your pull request only fixes a typo, don't\nhesitate to send it. If it's useful and good quality, it will be merged.\n\n\nAm I going to be attributed for my contribution?\n\n\nYes. Each release will list the names of contributors. If you don't want to be attributed, please\nstate it explicitly in the pull request. If you don't have your name on your Github profile or in\nthe commit, your username will be used.\n\n\nWhat can be contributed\n\n\nIssues\n\n\nIf you find any issues with a released or development version of \nrpclib\n, open an issue ticket on\nGithub. Please try to include:\n\n\n\n\nas many details as possible\n\n\nexact steps for reproducing the problem (if applicable)\n\n\npedantic description of what the expected behavior would be\n\n\n\n\nCode\n\n\nCode contributions are welcome as well, no matter how small they are.\n\n\nSome guidelines (this section will be expanded later):\n\n\n\n\nUse clang-format with the included configuration file\n\n\nAvoid whitespace-only diffs in files\n\n\nUse descriptive commit messages that can serve as a useful piece of code history\n\n\nMake sure that all unit tests pass\n\n\nWrite new, meaningful unit tests for new code\n\n\nDocument any public code with doxygen\n\n\nUpdate the documentation in the docs folder (if applicable)\n\n\nAdd examples to the \nCookbook\n\n\nDon't add external dependencies\n\n\n\n\nPull requests for open issues are preferred over others.\n\n\nPlease keep in mind that some pull requests may not fit into the vision of the project and may be\nrejected despite matching the above criteria. If you start working on a larger code contribution, it might be a good idea to let the project know about it (especially if there is no open issue about it).\n\n\nSupport scripts\n\n\nrpclib\n is not only C++: it uses a fair amount of CMake, bash, Powershell and python to achieve\nthe end result. These supporting scripts also require continued development, refactoring, cleanup\nand new features. Innovative ideas about how to do this all better are welcome (it's kind of a mess now, admittedly).\n\n\nExample projects\n\n\nThe more example projects \nrpclib\n ships with, the better. This is perhaps the most rewarding code\ncontribution option, because the guidelines are less strict regarding these.\n\n\n\n\nCreate both a server and client application\n\n\nCreate a CMakeLists.txt (similarly to existing ones)\n\n\nMake sure that your example application demonstrates a use-case that is not demonstrated by\n    other examples (don't worry, there are plenty of those)\n\n\nAdd lots of coments that explain the code\n\n\nYou may add any external dependencies\n\n\n\n\nDocumentation, proofreading\n\n\nrpclib\n aims to have an exemplary quality documenation. I'm not a native speaker, so it's likely\nthat there are sentences with weird constructs, misspelled words or just typos in many places.\nCorrecting those are invaluable help for me. To top it off, there is always room to expand, clean\nup and just generally improve the documentation to provide an easy learning curve for new users of\nthe library.\n\n\nHTML+CSS\n\n\nThe very site you are reading now is built using mkdocs and doxygen; but in some places it contains\nhand-written HTML and CSS. This is not my area of expertise. But documentation is not only about\ncontent, it's also the presentation. Changes that improve the robustness of the HTML and CSS are a huge win for the project.", 
            "title": "Contributing"
        }, 
        {
            "location": "/contributing/#why-contribute", 
            "text": "At the moment, this project is an approachable, intermediate-advanced level C++ project. If you contribute code, you may deepen your knowledge in these areas:   RPC clients and servers  Networking (through asio), TCP  Scalable architecture  Async programming  Template metaprogramming * Modern C++ (C++14 and beyond) * Google Test and Google Mock  Travis CI   Appveyor  Continous delivery  CMake", 
            "title": "Why contribute"
        }, 
        {
            "location": "/contributing/#ive-never-contributed-to-open-source-can-i-try-here", 
            "text": "Absolutely! First-time contributors are very much welcome in this project. Having your pull request\naccepted by a project is a great accomplishment. Even if your pull request only fixes a typo, don't\nhesitate to send it. If it's useful and good quality, it will be merged.", 
            "title": "I've never contributed to open source, can I try here?"
        }, 
        {
            "location": "/contributing/#am-i-going-to-be-attributed-for-my-contribution", 
            "text": "Yes. Each release will list the names of contributors. If you don't want to be attributed, please\nstate it explicitly in the pull request. If you don't have your name on your Github profile or in\nthe commit, your username will be used.", 
            "title": "Am I going to be attributed for my contribution?"
        }, 
        {
            "location": "/contributing/#what-can-be-contributed", 
            "text": "", 
            "title": "What can be contributed"
        }, 
        {
            "location": "/contributing/#issues", 
            "text": "If you find any issues with a released or development version of  rpclib , open an issue ticket on\nGithub. Please try to include:   as many details as possible  exact steps for reproducing the problem (if applicable)  pedantic description of what the expected behavior would be", 
            "title": "Issues"
        }, 
        {
            "location": "/contributing/#code", 
            "text": "Code contributions are welcome as well, no matter how small they are.  Some guidelines (this section will be expanded later):   Use clang-format with the included configuration file  Avoid whitespace-only diffs in files  Use descriptive commit messages that can serve as a useful piece of code history  Make sure that all unit tests pass  Write new, meaningful unit tests for new code  Document any public code with doxygen  Update the documentation in the docs folder (if applicable)  Add examples to the  Cookbook  Don't add external dependencies   Pull requests for open issues are preferred over others.  Please keep in mind that some pull requests may not fit into the vision of the project and may be\nrejected despite matching the above criteria. If you start working on a larger code contribution, it might be a good idea to let the project know about it (especially if there is no open issue about it).", 
            "title": "Code"
        }, 
        {
            "location": "/contributing/#support-scripts", 
            "text": "rpclib  is not only C++: it uses a fair amount of CMake, bash, Powershell and python to achieve\nthe end result. These supporting scripts also require continued development, refactoring, cleanup\nand new features. Innovative ideas about how to do this all better are welcome (it's kind of a mess now, admittedly).", 
            "title": "Support scripts"
        }, 
        {
            "location": "/contributing/#example-projects", 
            "text": "The more example projects  rpclib  ships with, the better. This is perhaps the most rewarding code\ncontribution option, because the guidelines are less strict regarding these.   Create both a server and client application  Create a CMakeLists.txt (similarly to existing ones)  Make sure that your example application demonstrates a use-case that is not demonstrated by\n    other examples (don't worry, there are plenty of those)  Add lots of coments that explain the code  You may add any external dependencies", 
            "title": "Example projects"
        }, 
        {
            "location": "/contributing/#documentation-proofreading", 
            "text": "rpclib  aims to have an exemplary quality documenation. I'm not a native speaker, so it's likely\nthat there are sentences with weird constructs, misspelled words or just typos in many places.\nCorrecting those are invaluable help for me. To top it off, there is always room to expand, clean\nup and just generally improve the documentation to provide an easy learning curve for new users of\nthe library.", 
            "title": "Documentation, proofreading"
        }, 
        {
            "location": "/contributing/#htmlcss", 
            "text": "The very site you are reading now is built using mkdocs and doxygen; but in some places it contains\nhand-written HTML and CSS. This is not my area of expertise. But documentation is not only about\ncontent, it's also the presentation. Changes that improve the robustness of the HTML and CSS are a huge win for the project.", 
            "title": "HTML+CSS"
        }, 
        {
            "location": "/reference/", 
            "text": ".table td {\n        text-align: left;\n    }\n\n    .table td:first-child {\n        text-align: right;\n        width: 230px;\n    }\u200b\n\n\n\n\nThis document is a detailed and (hopefully) complete reference of the public interface of \nrpclib\n.\nFor a tutorial, take a look at the \nPrimer\n. Also, you can find many examples in the \nCookbook\n.\n\n\nnonstd::optional_lite::bad_optional_access\n\n\n#include\n \nrpc/nonstd/optional.hpp\n\n\n\n\n\n\nDescription\n\n\noptional access error \n\n\nPublic functions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbad_optional_access\n()\n\n\n\n\n\n\n\n\n~bad_optional_access\n()\n\n\n\n\n\n\n\n\nnonstd::optional_lite::bad_optional_access::bad_optional_access\n\n\n\n \nnonstd\n::\noptional_lite\n::\nbad_optional_access\n::\nbad_optional_access\n();\n\n\n\n\n\n\nnonstd::optional_lite::bad_optional_access::~bad_optional_access\n\n\n\n \nnonstd\n::\noptional_lite\n::\nbad_optional_access\n::~\nbad_optional_access\n();\n\n\n\n\n\n\nrpc::client\n\n\n#include\n \nrpc/client.h\n\n\n\n\n\n\nDescription\n\n\nImplements a client that connects to a msgpack-rpc server and is able to call functions synchronously or asynchronously. This is the main interfacing point for implementing client applications. \n\n\nUse this class to connect to msgpack-rpc servers and call their exposed functions. This class supports calling functions synchronously and asynchronously. When the client object is created, it initiates connecting to the given server asynchronically and disconnects when it is destroyed. \n\n\nPublic functions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclient\n(std::string const \naddr, uint16_t port)\n\n\n\n\n\n\n\n\n~client\n()\n\n\n\n\n\n\nRPCLIB_MSGPACK::object_handle\n\n\ncall\n(std::string const \nfunc_name, Args... args)\n\n\n\n\n\n\nstd::future\n RPCLIB_MSGPACK::object_handle \n\n\nasync_call\n(std::string const \nfunc_name, Args... args)\n\n\n\n\n\n\nvoid\n\n\nsend\n(std::string const \nfunc_name, Args... args)\n\n\n\n\n\n\nnonstd::optional\n\n\nget_timeout\n() const\n\n\n\n\n\n\nvoid\n\n\nset_timeout\n(int64_t value)\n\n\n\n\n\n\nconnection_state\n\n\nget_connection_state\n() const\n\n\n\n\n\n\nvoid\n\n\nwait_all_responses\n()\n\n\n\n\n\n\n\n\nrpc::client::client\n\n\n\n \nrpc\n::\nclient\n::\nclient\n(\nstd\n::\nstring\n \nconst\n \naddr\n,\n \nuint16_t\n \nport\n);\n\n\n\n\n\n\nConstructs a client. \n\n\nParameters\n\n\naddr\n The address of the server to connect to. This might be an IP address or a host name, too. \n\n\nport\n The port on the server to connect to. \n\n\nDetails\n\n\nWhen a client is constructed, it initiates a connection asynchronically. This means that it will not block while the connection is established. However, when the first call is performed, it \nmight\n block if the connection was not already established.\n\n\nrpc::client::~client\n\n\n\n \nrpc\n::\nclient\n::~\nclient\n();\n\n\n\n\n\n\nDestructor. \n\n\nDetails\n\n\nDuring destruction, the connection to the server is gracefully closed. This means that any outstanding reads and writes are completed first. \n\n\nrpc::client::call\n\n\n\nRPCLIB_MSGPACK\n::\nobject_handle\n \nrpc\n::\nclient\n::\ncall\n(\nstd\n::\nstring\n \nconst\n \nfunc_name\n,\n \nArgs\n...\n \nargs\n);\n\n\n\n\n\n\nCalls a function with the given name and arguments (if any). \n\n\nTemplate parameters\n\n\nArgs\n The types of the arguments. Each type in this parameter pack have to be serializable by msgpack.\n\n\nParameters\n\n\nfunc_name\n The name of the function to call on the server. \n\n\nargs\n A variable number of arguments to pass to the called function.\n\n\nReturn value\n\n\nA RPCLIB_MSGPACK::object containing the result of the function (if any). To obtain a typed value, use the msgpack API.\n\n\nrpc::client::async_call\n\n\n\nstd\n::\nfuture\n \nRPCLIB_MSGPACK\n::\nobject_handle\n \n \nrpc\n::\nclient\n::\nasync_call\n(\nstd\n::\nstring\n \nconst\n \nfunc_name\n,\n \nArgs\n...\n \nargs\n);\n\n\n\n\n\n\nCalls a function asynchronously with the given name and arguments. \n\n\nTemplate parameters\n\n\nArgs\n The types of the arguments.\n\n\nParameters\n\n\nfunc_name\n The name of the function to call. \n\n\nargs\n The arguments to pass to the function.\n\n\nDetails\n\n\nA call is performed asynchronously in the context of the client, i.e. this is not to be confused with parallel execution on the server. This function differs from \ncall\n in that it does not wait for the result of the function. Instead, it returns a std::future that can be used to retrieve the result later.\n\n\nReturn value\n\n\nA std::future, possibly holding a future result (which is a RPCLIB_MSGPACK::object). \n\n\nrpc::client::send\n\n\n\nvoid\n \nrpc\n::\nclient\n::\nsend\n(\nstd\n::\nstring\n \nconst\n \nfunc_name\n,\n \nArgs\n...\n \nargs\n);\n\n\n\n\n\n\nSends a notification with the given name and arguments (if any). \n\n\nTemplate parameters\n\n\nArgs\n THe types of the arguments.\n\n\nParameters\n\n\nfunc_name\n The name of the notification to call. \n\n\nargs\n The arguments to pass to the function. \n\n\nDetails\n\n\nNotifications are a special kind of calls. They can be used to notify the server, while not expecting a response. In \nrpclib\n terminology, a notification is like an \nasync_call\n without a return value.\n\n\n\n\nWarn\n\n\nThis function returns immediately (possibly before the notification is written to the socket).\n\n\n\n\nrpc::client::get_timeout\n\n\n\nnonstd\n::\noptional\n \nrpc\n::\nclient\n::\nget_timeout\n()\n \nconst\n;\n\n\n\n\n\n\nReturns the timeout setting of this client in milliseconds. \n\n\nDetails\n\n\nThe timeout is applied to synchronous calls. If the timeout expires without receiving a response from the server, \n\n\n\n\nWarn\n\n\nThe timeout has no effect on async calls. For those, the preferred timeout mechanism remains using std::future.\n\n\n\n\nrpc::client::set_timeout\n\n\n\nvoid\n \nrpc\n::\nclient\n::\nset_timeout\n(\nint64_t\n \nvalue\n);\n\n\n\n\n\n\nSets the timeout for synchronous calls. For more information, see \n\n\nrpc::client::get_connection_state\n\n\n\nconnection_state\n \nrpc\n::\nclient\n::\nget_connection_state\n()\n \nconst\n;\n\n\n\n\n\n\nReturns the current connection state. \n\n\nrpc::client::wait_all_responses\n\n\n\nvoid\n \nrpc\n::\nclient\n::\nwait_all_responses\n();\n\n\n\n\n\n\nWaits for the completion of all ongoing calls. \n\n\nnonstd::optional_lite::optional\n\n\n#include\n \nrpc/nonstd/optional.hpp\n\n\n\n\n\n\nDescription\n\n\nclass optional \n\n\noptional \n\n\nPublic functions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\noptional_constexpr\n\n\noptional\n() optional_noexcept\n\n\n\n\n\n\noptional_constexpr\n\n\noptional\n(nullopt_t) optional_noexcept\n\n\n\n\n\n\n\n\noptional\n(optional const \nrhs)\n\n\n\n\n\n\noptional_constexpr\n\n\noptional\n(value_type const \nvalue)\n\n\n\n\n\n\n\n\n~optional\n()\n\n\n\n\n\n\noptional\n\n\noperator=\n(nullopt_t) optional_noexcept\n\n\n\n\n\n\noptional\n\n\noperator=\n(optional const \nrhs)\n\n\n\n\n\n\nvoid\n\n\nswap\n(optional \nrhs)\n\n\n\n\n\n\noptional_constexpr value_type const  *\n\n\noperator-\n() const\n\n\n\n\n\n\noptional_constexpr14 value_type *\n\n\noperator-\n()\n\n\n\n\n\n\noptional_constexpr value_type const  \n\n\noperator*\n() const optional_ref_qual\n\n\n\n\n\n\noptional_constexpr14 value_type \n\n\noperator*\n() optional_ref_qual\n\n\n\n\n\n\noptional_constexpr\n\n\noperator safe_bool\n() const optional_noexcept\n\n\n\n\n\n\noptional_constexpr bool\n\n\nhas_value\n() const optional_noexcept\n\n\n\n\n\n\noptional_constexpr14 value_type const  \n\n\nvalue\n() const optional_ref_qual\n\n\n\n\n\n\noptional_constexpr14 value_type \n\n\nvalue\n() optional_ref_qual\n\n\n\n\n\n\noptional_constexpr value_type\n\n\nvalue_or\n(U const \nv) const\n\n\n\n\n\n\nvoid\n\n\nreset\n() optional_noexcept\n\n\n\n\n\n\n\n\nnonstd::optional_lite::optional::optional\n\n\n\noptional_constexpr\n \nnonstd\n::\noptional_lite\n::\noptional\n::\noptional\n()\n \noptional_noexcept\n;\n\n\n\n\n\n\nnonstd::optional_lite::optional::optional\n\n\n\noptional_constexpr\n \nnonstd\n::\noptional_lite\n::\noptional\n::\noptional\n(\nnullopt_t\n)\n \noptional_noexcept\n;\n\n\n\n\n\n\nnonstd::optional_lite::optional::optional\n\n\n\n \nnonstd\n::\noptional_lite\n::\noptional\n::\noptional\n(\noptional\n \nconst\n \nrhs\n);\n\n\n\n\n\n\nnonstd::optional_lite::optional::optional\n\n\n\noptional_constexpr\n \nnonstd\n::\noptional_lite\n::\noptional\n::\noptional\n(\nvalue_type\n \nconst\n \nvalue\n);\n\n\n\n\n\n\nnonstd::optional_lite::optional::~optional\n\n\n\n \nnonstd\n::\noptional_lite\n::\noptional\n::~\noptional\n();\n\n\n\n\n\n\nnonstd::optional_lite::optional::operator=\n\n\n\noptional\n \nnonstd\n::\noptional_lite\n::\noptional\n::\noperator\n=\n(\nnullopt_t\n)\n \noptional_noexcept\n;\n\n\n\n\n\n\nnonstd::optional_lite::optional::operator=\n\n\n\noptional\n \nnonstd\n::\noptional_lite\n::\noptional\n::\noperator\n=\n(\noptional\n \nconst\n \nrhs\n);\n\n\n\n\n\n\nnonstd::optional_lite::optional::swap\n\n\n\nvoid\n \nnonstd\n::\noptional_lite\n::\noptional\n::\nswap\n(\noptional\n \nrhs\n);\n\n\n\n\n\n\nnonstd::optional_lite::optional::operator->\n\n\n\noptional_constexpr\n \nvalue_type\n \nconst\n  \n*\n \nnonstd\n::\noptional_lite\n::\noptional\n::\noperator\n-\n()\n \nconst\n;\n\n\n\n\n\n\nnonstd::optional_lite::optional::operator->\n\n\n\noptional_constexpr14\n \nvalue_type\n \n*\n \nnonstd\n::\noptional_lite\n::\noptional\n::\noperator\n-\n();\n\n\n\n\n\n\nnonstd::optional_lite::optional::operator*\n\n\n\noptional_constexpr\n \nvalue_type\n \nconst\n  \n \nnonstd\n::\noptional_lite\n::\noptional\n::\noperator\n*\n()\n \nconst\n \noptional_ref_qual\n;\n\n\n\n\n\n\nnonstd::optional_lite::optional::operator*\n\n\n\noptional_constexpr14\n \nvalue_type\n \n \nnonstd\n::\noptional_lite\n::\noptional\n::\noperator\n*\n()\n \noptional_ref_qual\n;\n\n\n\n\n\n\nnonstd::optional_lite::optional::operator safe_bool\n\n\n\noptional_constexpr\n \nnonstd\n::\noptional_lite\n::\noptional\n::\noperator\n \nsafe_bool\n()\n \nconst\n \noptional_noexcept\n;\n\n\n\n\n\n\nnonstd::optional_lite::optional::has_value\n\n\n\noptional_constexpr\n \nbool\n \nnonstd\n::\noptional_lite\n::\noptional\n::\nhas_value\n()\n \nconst\n \noptional_noexcept\n;\n\n\n\n\n\n\nnonstd::optional_lite::optional::value\n\n\n\noptional_constexpr14\n \nvalue_type\n \nconst\n  \n \nnonstd\n::\noptional_lite\n::\noptional\n::\nvalue\n()\n \nconst\n \noptional_ref_qual\n;\n\n\n\n\n\n\nnonstd::optional_lite::optional::value\n\n\n\noptional_constexpr14\n \nvalue_type\n \n \nnonstd\n::\noptional_lite\n::\noptional\n::\nvalue\n()\n \noptional_ref_qual\n;\n\n\n\n\n\n\nnonstd::optional_lite::optional::value_or\n\n\n\noptional_constexpr\n \nvalue_type\n \nnonstd\n::\noptional_lite\n::\noptional\n::\nvalue_or\n(\nU\n \nconst\n \nv\n)\n \nconst\n;\n\n\n\n\n\n\nnonstd::optional_lite::optional::reset\n\n\n\nvoid\n \nnonstd\n::\noptional_lite\n::\noptional\n::\nreset\n()\n \noptional_noexcept\n;\n\n\n\n\n\n\nrpc::rpc_error\n\n\n#include\n \nrpc/rpc_error.h\n\n\n\n\n\n\nDescription\n\n\nThis exception is thrown by the client when the server signals an error during a call. \n\n\nThis type allows clients to handle arbitrary error objects as the msgpack-rpc specification allows. In client code you probably don't want to throw it, hence its constructor is private. \n\n\nPublic functions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::string\n\n\nget_function_name\n() const\n\n\n\n\n\n\nRPCLIB_MSGPACK::object_handle \n\n\nget_error\n()\n\n\n\n\n\n\n\n\nrpc::rpc_error::get_function_name\n\n\n\nstd\n::\nstring\n \nrpc\n::\nrpc_error\n::\nget_function_name\n()\n \nconst\n;\n\n\n\n\n\n\nReturns the name of the function that was called on the server while the error occurred. \n\n\nrpc::rpc_error::get_error\n\n\n\nRPCLIB_MSGPACK\n::\nobject_handle\n \n \nrpc\n::\nrpc_error\n::\nget_error\n();\n\n\n\n\n\n\nReturns the error object that the server provided. \n\n\nrpc::server\n\n\n#include\n \nrpc/server.h\n\n\n\n\n\n\nDescription\n\n\nImplements a msgpack-rpc server. This is the main interfacing point with the library for creating servers. \n\n\nThe server maintains a registry of function bindings that it uses to dispatch calls. It also takes care of managing worker threads and TCP connections. The server does not start listening right after construction in order to allow binding functions before that. Use the \nrun\n or \nasync_run\n functions to start listening on the port. This class is not copyable, but moveable. \n\n\nPublic functions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nserver\n(uint16_t port)\n\n\n\n\n\n\n\n\nserver\n(server \nother) noexcept\n\n\n\n\n\n\n\n\nserver\n(std::string const \naddress, uint16_t port)\n\n\n\n\n\n\n\n\n~server\n()\n\n\n\n\n\n\nserver\n\n\noperator=\n(server \nother)\n\n\n\n\n\n\nvoid\n\n\nrun\n()\n\n\n\n\n\n\nvoid\n\n\nasync_run\n(std::size_t worker_threads=1)\n\n\n\n\n\n\nvoid\n\n\nbind\n(std::string const \nname, F func)\n\n\n\n\n\n\nvoid\n\n\nsuppress_exceptions\n(bool suppress)\n\n\n\n\n\n\nvoid\n\n\nstop\n()\n\n\n\n\n\n\nvoid\n\n\nclose_sessions\n()\n\n\n\n\n\n\n\n\nrpc::server::server\n\n\n\n \nrpc\n::\nserver\n::\nserver\n(\nuint16_t\n \nport\n);\n\n\n\n\n\n\nConstructs a server that listens on the localhost on the specified port. \n\n\nParameters\n\n\nport\n The port number to listen on. \n\n\nrpc::server::server\n\n\n\n \nrpc\n::\nserver\n::\nserver\n(\nserver\n \nother\n)\n \nnoexcept\n;\n\n\n\n\n\n\nMove constructor. This is implemented by calling the move assignment operator. \n\n\nParameters\n\n\nother\n The other instance to move from. \n\n\nrpc::server::server\n\n\n\n \nrpc\n::\nserver\n::\nserver\n(\nstd\n::\nstring\n \nconst\n \naddress\n,\n \nuint16_t\n \nport\n);\n\n\n\n\n\n\nConstructs a server that listens on the specified address on the specified port. \n\n\nParameters\n\n\nport\n The port number to listen on. \n\n\nrpc::server::~server\n\n\n\n \nrpc\n::\nserver\n::~\nserver\n();\n\n\n\n\n\n\nDestructor. \n\n\nDetails\n\n\nWhen the server is destroyed, all ongoin sessions are closed gracefully. \n\n\nrpc::server::operator=\n\n\n\nserver\n \nrpc\n::\nserver\n::\noperator\n=\n(\nserver\n \nother\n);\n\n\n\n\n\n\nMove assignment operator. \n\n\nParameters\n\n\nother\n The other instance to move from. \n\n\nReturn value\n\n\nThe result of the assignment. \n\n\nrpc::server::run\n\n\n\nvoid\n \nrpc\n::\nserver\n::\nrun\n();\n\n\n\n\n\n\nStarts the server loop. This is a blocking call. \n\n\nDetails\n\n\nFirst and foremost, running the event loop causes the server to start listening on the specified port. Also, as connections are established and calls are made by clients, the server executes the calls as part of this call. This means that the handlers are executed on the thread that calls \nrun\n. Reads and writes are initiated by this function internally as well. \n\n\nrpc::server::async_run\n\n\n\nvoid\n \nrpc\n::\nserver\n::\nasync_run\n(\nstd\n::\nsize_t\n \nworker_threads\n=\n1\n);\n\n\n\n\n\n\nStarts the server loop on one or more threads. This is a non-blocking call. \n\n\nParameters\n\n\nworker_threads\n The number of worker threads to start. \n\n\nDetails\n\n\nThis function behaves similarly to \nrun\n, except the event loop is optionally started on different threads. Effectively this sets up a worker thread pool for the server. Handlers will be executed on one of the threads.\n\n\nrpc::server::bind\n\n\n\nvoid\n \nrpc\n::\nserver\n::\nbind\n(\nstd\n::\nstring\n \nconst\n \nname\n,\n \nF\n \nfunc\n);\n\n\n\n\n\n\nBinds a functor to a name so it becomes callable via RPC. \n\n\nTemplate parameters\n\n\nF\n The type of the functor. \n\n\nParameters\n\n\nname\n The name of the functor. \n\n\nfunc\n The functor to bind. \n\n\nDetails\n\n\nThis function template accepts a wide range of callables. The arguments and return types of these callables should be serializable by msgpack. \nbind\n effectively generates a suitable, light-weight compile-time wrapper for the functor.\n\n\nrpc::server::suppress_exceptions\n\n\n\nvoid\n \nrpc\n::\nserver\n::\nsuppress_exceptions\n(\nbool\n \nsuppress\n);\n\n\n\n\n\n\nSets the exception behavior in handlers. By default, handlers throwing will crash the server. If suppressing is on, the server will try to gather textual data and return it to the client as an error response. \n\n\n\n\nWarn\n\n\nSetting this flag only affects subsequent connections. \n\n\n\n\nrpc::server::stop\n\n\n\nvoid\n \nrpc\n::\nserver\n::\nstop\n();\n\n\n\n\n\n\nStops the server. \n\n\n\n\nWarn\n\n\nThis should not be called from worker threads. \n\n\n\n\nrpc::server::close_sessions\n\n\n\nvoid\n \nrpc\n::\nserver\n::\nclose_sessions\n();\n\n\n\n\n\n\nCloses all sessions gracefully. \n\n\nrpc::this_handler_t\n\n\n#include\n \nrpc/this_handler.h\n\n\n\n\n\n\nDescription\n\n\nEncapsulates information about the currently executing handler. This is the interface through which bound functions may return errors, arbitrary type responses or prohibit sending a response. \n\n\nPublic functions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid\n\n\nrespond_error\n(T \nerr_obj)\n\n\n\n\n\n\nvoid\n\n\nrespond\n(T \nresp_obj)\n\n\n\n\n\n\nvoid\n\n\ndisable_response\n()\n\n\n\n\n\n\nvoid\n\n\nenable_response\n()\n\n\n\n\n\n\nvoid\n\n\nclear\n()\n\n\n\n\n\n\n\n\nrpc::this_handler_t::respond_error\n\n\n\nvoid\n \nrpc\n::\nthis_handler_t\n::\nrespond_error\n(\nT\n \nerr_obj\n);\n\n\n\n\n\n\nSets an arbitrary object to be sent back as an error response to the client. \n\n\nTemplate parameters\n\n\nT\n The type of the error object. \n\n\nParameters\n\n\nerr_obj\n The error object. This can be anything that is possible to encode with messagepack (even custom structures). \n\n\nrpc::this_handler_t::respond\n\n\n\nvoid\n \nrpc\n::\nthis_handler_t\n::\nrespond\n(\nT\n \nresp_obj\n);\n\n\n\n\n\n\nSets an arbitrary object to be sent back as the response to the call. \n\n\nTemplate parameters\n\n\nT\n The type of the response object. \n\n\nParameters\n\n\nresp_obj\n The response object. This can be anything that is possible to encode with messagepack (even custom structures). \n\n\n\n\nWarn\n\n\nThe normal return value of the function (if any) will be ignored if a special response is set. \n\n\n\n\nrpc::this_handler_t::disable_response\n\n\n\nvoid\n \nrpc\n::\nthis_handler_t\n::\ndisable_response\n();\n\n\n\n\n\n\nInstructs the server to not send a response to the client (ignoring any errors and return values). \n\n\n\n\nWarn\n\n\nIt is unusual to not send a response to requests, and doing so might cause problems in the client (depending on its implementation). \n\n\n\n\nrpc::this_handler_t::enable_response\n\n\n\nvoid\n \nrpc\n::\nthis_handler_t\n::\nenable_response\n();\n\n\n\n\n\n\nEnables sending a response to the call. Sending the response is by default enabled. Enabling the response multiple times have no effect. \n\n\nrpc::this_handler_t::clear\n\n\n\nvoid\n \nrpc\n::\nthis_handler_t\n::\nclear\n();\n\n\n\n\n\n\nSets all state of the object to default. \n\n\nrpc::this_server_t\n\n\n#include\n \nrpc/this_server.h\n\n\n\n\n\n\nDescription\n\n\nAllows controlling the server instance from the currently executing handler. \n\n\nPublic functions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid\n\n\nstop\n()\n\n\n\n\n\n\nvoid\n\n\ncancel_stop\n()\n\n\n\n\n\n\n\n\nrpc::this_server_t::stop\n\n\n\nvoid\n \nrpc\n::\nthis_server_t\n::\nstop\n();\n\n\n\n\n\n\nGracefully stops the server. \n\n\nrpc::this_server_t::cancel_stop\n\n\n\nvoid\n \nrpc\n::\nthis_server_t\n::\ncancel_stop\n();\n\n\n\n\n\n\nCancels a requested stop operation. \n\n\nrpc::this_session_t\n\n\n#include\n \nrpc/this_session.h\n\n\n\n\n\n\nDescription\n\n\nEncapsulates information about the server session/connection this handler is running in. This is the interface through which bound functions may interact with the session. \n\n\nPublic functions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid\n\n\npost_exit\n()\n\n\n\n\n\n\n\n\nrpc::this_session_t::post_exit\n\n\n\nvoid\n \nrpc\n::\nthis_session_t\n::\npost_exit\n();\n\n\n\n\n\n\nGracefully exits the session (i.e. ongoing writes and reads are completed; queued writes and reads are not). \n\n\n\n\nWarn\n\n\nUse this function if you need to close the connection from a handler. \n\n\n\n\nrpc::timeout\n\n\n#include\n \n\n\n\n\n\n\nDescription\n\n\nPublic functions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst char *\n\n\nwhat\n() const noexcept override\n\n\n\n\n\n\n\n\nrpc::timeout::what\n\n\n\nconst\n \nchar\n \n*\n \nrpc\n::\ntimeout\n::\nwhat\n()\n \nconst\n \nnoexcept\n \noverride\n;", 
            "title": "Reference"
        }, 
        {
            "location": "/reference/#nonstdoptional_litebad_optional_access", 
            "text": "#include   rpc/nonstd/optional.hpp", 
            "title": "nonstd::optional_lite::bad_optional_access"
        }, 
        {
            "location": "/reference/#description", 
            "text": "optional access error", 
            "title": "Description"
        }, 
        {
            "location": "/reference/#public-functions", 
            "text": "bad_optional_access ()     ~bad_optional_access ()", 
            "title": "Public functions"
        }, 
        {
            "location": "/reference/#rpcclient", 
            "text": "#include   rpc/client.h", 
            "title": "rpc::client"
        }, 
        {
            "location": "/reference/#description_1", 
            "text": "Implements a client that connects to a msgpack-rpc server and is able to call functions synchronously or asynchronously. This is the main interfacing point for implementing client applications.   Use this class to connect to msgpack-rpc servers and call their exposed functions. This class supports calling functions synchronously and asynchronously. When the client object is created, it initiates connecting to the given server asynchronically and disconnects when it is destroyed.", 
            "title": "Description"
        }, 
        {
            "location": "/reference/#public-functions_1", 
            "text": "client (std::string const  addr, uint16_t port)     ~client ()    RPCLIB_MSGPACK::object_handle  call (std::string const  func_name, Args... args)    std::future  RPCLIB_MSGPACK::object_handle   async_call (std::string const  func_name, Args... args)    void  send (std::string const  func_name, Args... args)    nonstd::optional  get_timeout () const    void  set_timeout (int64_t value)    connection_state  get_connection_state () const    void  wait_all_responses ()", 
            "title": "Public functions"
        }, 
        {
            "location": "/reference/#parameters", 
            "text": "addr  The address of the server to connect to. This might be an IP address or a host name, too.   port  The port on the server to connect to.", 
            "title": "Parameters"
        }, 
        {
            "location": "/reference/#details", 
            "text": "When a client is constructed, it initiates a connection asynchronically. This means that it will not block while the connection is established. However, when the first call is performed, it  might  block if the connection was not already established.", 
            "title": "Details"
        }, 
        {
            "location": "/reference/#details_1", 
            "text": "During destruction, the connection to the server is gracefully closed. This means that any outstanding reads and writes are completed first.", 
            "title": "Details"
        }, 
        {
            "location": "/reference/#template-parameters", 
            "text": "Args  The types of the arguments. Each type in this parameter pack have to be serializable by msgpack.", 
            "title": "Template parameters"
        }, 
        {
            "location": "/reference/#parameters_1", 
            "text": "func_name  The name of the function to call on the server.   args  A variable number of arguments to pass to the called function.", 
            "title": "Parameters"
        }, 
        {
            "location": "/reference/#return-value", 
            "text": "A RPCLIB_MSGPACK::object containing the result of the function (if any). To obtain a typed value, use the msgpack API.", 
            "title": "Return value"
        }, 
        {
            "location": "/reference/#template-parameters_1", 
            "text": "Args  The types of the arguments.", 
            "title": "Template parameters"
        }, 
        {
            "location": "/reference/#parameters_2", 
            "text": "func_name  The name of the function to call.   args  The arguments to pass to the function.", 
            "title": "Parameters"
        }, 
        {
            "location": "/reference/#details_2", 
            "text": "A call is performed asynchronously in the context of the client, i.e. this is not to be confused with parallel execution on the server. This function differs from  call  in that it does not wait for the result of the function. Instead, it returns a std::future that can be used to retrieve the result later.", 
            "title": "Details"
        }, 
        {
            "location": "/reference/#return-value_1", 
            "text": "A std::future, possibly holding a future result (which is a RPCLIB_MSGPACK::object).", 
            "title": "Return value"
        }, 
        {
            "location": "/reference/#template-parameters_2", 
            "text": "Args  THe types of the arguments.", 
            "title": "Template parameters"
        }, 
        {
            "location": "/reference/#parameters_3", 
            "text": "func_name  The name of the notification to call.   args  The arguments to pass to the function.", 
            "title": "Parameters"
        }, 
        {
            "location": "/reference/#details_3", 
            "text": "Notifications are a special kind of calls. They can be used to notify the server, while not expecting a response. In  rpclib  terminology, a notification is like an  async_call  without a return value.   Warn  This function returns immediately (possibly before the notification is written to the socket).", 
            "title": "Details"
        }, 
        {
            "location": "/reference/#details_4", 
            "text": "The timeout is applied to synchronous calls. If the timeout expires without receiving a response from the server,    Warn  The timeout has no effect on async calls. For those, the preferred timeout mechanism remains using std::future.", 
            "title": "Details"
        }, 
        {
            "location": "/reference/#nonstdoptional_liteoptional", 
            "text": "#include   rpc/nonstd/optional.hpp", 
            "title": "nonstd::optional_lite::optional"
        }, 
        {
            "location": "/reference/#description_2", 
            "text": "class optional   optional", 
            "title": "Description"
        }, 
        {
            "location": "/reference/#public-functions_2", 
            "text": "optional_constexpr  optional () optional_noexcept    optional_constexpr  optional (nullopt_t) optional_noexcept     optional (optional const  rhs)    optional_constexpr  optional (value_type const  value)     ~optional ()    optional  operator= (nullopt_t) optional_noexcept    optional  operator= (optional const  rhs)    void  swap (optional  rhs)    optional_constexpr value_type const  *  operator- () const    optional_constexpr14 value_type *  operator- ()    optional_constexpr value_type const    operator* () const optional_ref_qual    optional_constexpr14 value_type   operator* () optional_ref_qual    optional_constexpr  operator safe_bool () const optional_noexcept    optional_constexpr bool  has_value () const optional_noexcept    optional_constexpr14 value_type const    value () const optional_ref_qual    optional_constexpr14 value_type   value () optional_ref_qual    optional_constexpr value_type  value_or (U const  v) const    void  reset () optional_noexcept", 
            "title": "Public functions"
        }, 
        {
            "location": "/reference/#rpcrpc_error", 
            "text": "#include   rpc/rpc_error.h", 
            "title": "rpc::rpc_error"
        }, 
        {
            "location": "/reference/#description_3", 
            "text": "This exception is thrown by the client when the server signals an error during a call.   This type allows clients to handle arbitrary error objects as the msgpack-rpc specification allows. In client code you probably don't want to throw it, hence its constructor is private.", 
            "title": "Description"
        }, 
        {
            "location": "/reference/#public-functions_3", 
            "text": "std::string  get_function_name () const    RPCLIB_MSGPACK::object_handle   get_error ()", 
            "title": "Public functions"
        }, 
        {
            "location": "/reference/#rpcserver", 
            "text": "#include   rpc/server.h", 
            "title": "rpc::server"
        }, 
        {
            "location": "/reference/#description_4", 
            "text": "Implements a msgpack-rpc server. This is the main interfacing point with the library for creating servers.   The server maintains a registry of function bindings that it uses to dispatch calls. It also takes care of managing worker threads and TCP connections. The server does not start listening right after construction in order to allow binding functions before that. Use the  run  or  async_run  functions to start listening on the port. This class is not copyable, but moveable.", 
            "title": "Description"
        }, 
        {
            "location": "/reference/#public-functions_4", 
            "text": "server (uint16_t port)     server (server  other) noexcept     server (std::string const  address, uint16_t port)     ~server ()    server  operator= (server  other)    void  run ()    void  async_run (std::size_t worker_threads=1)    void  bind (std::string const  name, F func)    void  suppress_exceptions (bool suppress)    void  stop ()    void  close_sessions ()", 
            "title": "Public functions"
        }, 
        {
            "location": "/reference/#parameters_4", 
            "text": "port  The port number to listen on.", 
            "title": "Parameters"
        }, 
        {
            "location": "/reference/#parameters_5", 
            "text": "other  The other instance to move from.", 
            "title": "Parameters"
        }, 
        {
            "location": "/reference/#parameters_6", 
            "text": "port  The port number to listen on.", 
            "title": "Parameters"
        }, 
        {
            "location": "/reference/#details_5", 
            "text": "When the server is destroyed, all ongoin sessions are closed gracefully.", 
            "title": "Details"
        }, 
        {
            "location": "/reference/#parameters_7", 
            "text": "other  The other instance to move from.", 
            "title": "Parameters"
        }, 
        {
            "location": "/reference/#return-value_2", 
            "text": "The result of the assignment.", 
            "title": "Return value"
        }, 
        {
            "location": "/reference/#details_6", 
            "text": "First and foremost, running the event loop causes the server to start listening on the specified port. Also, as connections are established and calls are made by clients, the server executes the calls as part of this call. This means that the handlers are executed on the thread that calls  run . Reads and writes are initiated by this function internally as well.", 
            "title": "Details"
        }, 
        {
            "location": "/reference/#parameters_8", 
            "text": "worker_threads  The number of worker threads to start.", 
            "title": "Parameters"
        }, 
        {
            "location": "/reference/#details_7", 
            "text": "This function behaves similarly to  run , except the event loop is optionally started on different threads. Effectively this sets up a worker thread pool for the server. Handlers will be executed on one of the threads.", 
            "title": "Details"
        }, 
        {
            "location": "/reference/#template-parameters_3", 
            "text": "F  The type of the functor.", 
            "title": "Template parameters"
        }, 
        {
            "location": "/reference/#parameters_9", 
            "text": "name  The name of the functor.   func  The functor to bind.", 
            "title": "Parameters"
        }, 
        {
            "location": "/reference/#details_8", 
            "text": "This function template accepts a wide range of callables. The arguments and return types of these callables should be serializable by msgpack.  bind  effectively generates a suitable, light-weight compile-time wrapper for the functor.", 
            "title": "Details"
        }, 
        {
            "location": "/reference/#rpcthis_handler_t", 
            "text": "#include   rpc/this_handler.h", 
            "title": "rpc::this_handler_t"
        }, 
        {
            "location": "/reference/#description_5", 
            "text": "Encapsulates information about the currently executing handler. This is the interface through which bound functions may return errors, arbitrary type responses or prohibit sending a response.", 
            "title": "Description"
        }, 
        {
            "location": "/reference/#public-functions_5", 
            "text": "void  respond_error (T  err_obj)    void  respond (T  resp_obj)    void  disable_response ()    void  enable_response ()    void  clear ()", 
            "title": "Public functions"
        }, 
        {
            "location": "/reference/#template-parameters_4", 
            "text": "T  The type of the error object.", 
            "title": "Template parameters"
        }, 
        {
            "location": "/reference/#parameters_10", 
            "text": "err_obj  The error object. This can be anything that is possible to encode with messagepack (even custom structures).", 
            "title": "Parameters"
        }, 
        {
            "location": "/reference/#template-parameters_5", 
            "text": "T  The type of the response object.", 
            "title": "Template parameters"
        }, 
        {
            "location": "/reference/#parameters_11", 
            "text": "resp_obj  The response object. This can be anything that is possible to encode with messagepack (even custom structures).    Warn  The normal return value of the function (if any) will be ignored if a special response is set.", 
            "title": "Parameters"
        }, 
        {
            "location": "/reference/#rpcthis_server_t", 
            "text": "#include   rpc/this_server.h", 
            "title": "rpc::this_server_t"
        }, 
        {
            "location": "/reference/#description_6", 
            "text": "Allows controlling the server instance from the currently executing handler.", 
            "title": "Description"
        }, 
        {
            "location": "/reference/#public-functions_6", 
            "text": "void  stop ()    void  cancel_stop ()", 
            "title": "Public functions"
        }, 
        {
            "location": "/reference/#rpcthis_session_t", 
            "text": "#include   rpc/this_session.h", 
            "title": "rpc::this_session_t"
        }, 
        {
            "location": "/reference/#description_7", 
            "text": "Encapsulates information about the server session/connection this handler is running in. This is the interface through which bound functions may interact with the session.", 
            "title": "Description"
        }, 
        {
            "location": "/reference/#public-functions_7", 
            "text": "void  post_exit ()", 
            "title": "Public functions"
        }, 
        {
            "location": "/reference/#rpctimeout", 
            "text": "#include", 
            "title": "rpc::timeout"
        }, 
        {
            "location": "/reference/#description_8", 
            "text": "", 
            "title": "Description"
        }, 
        {
            "location": "/reference/#public-functions_8", 
            "text": "const char *  what () const noexcept override", 
            "title": "Public functions"
        }, 
        {
            "location": "/versions/", 
            "text": "You are reading the documentation of 2.1.0. \nIf, for some reason you need the documentation of older versions, you can download them from this page.\n\n\n\n\n1.0.0", 
            "title": "Versions"
        }
    ]
}