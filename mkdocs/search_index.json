{
    "docs": [
        {
            "location": "/",
            "text": "rpclib - modern msgpack-rpc for C++\n\n\nWelcome to the documentation of \nrpclib\n! \nrpclib\n is a msgpack-rpc implementation written using modern C++. The goal of this library is to provide a simple, no-nonsense RPC solution.\n\n\nDocumentation\n\n\n\n\nGetting started\n: Requirements, installation - everything you need to be able to start using \nrpclib\n\n\nPrimer\n: A longer tutorial introduction to using the library, intended for newcomers\n\n\nCookbook\n: Recipes for common tasks the library was designed for handling, in the form of short examples\n\n\nBuilding\n: Basic and advanced building options.\n\n\nGlossary\n: Collection of definitions used by the library.\n\n\nReference\n: Complete reference of the \nrpclib\n API.\n\n\nMsgPack-RPC specification\n: The specification of the Msgpack-RPC protocol, as \nrpclib\n implements it\n\n\nRoadmap\n: Planned features\n\n\n\n\nWhat does it look like?\n\n\nHere is a very simple example, a kind of hello world for network-related libraries:\n\n\n#include \"rpc/server.h\"\n\nint main() {\n    rpc::server srv(8080);\n\n    srv.bind(\"echo\", [](std::string const& s) {\n        return s;\n    });\n\n    srv.run();\n    return 0;\n}\n\n\n\n\n#include \"rpc/client.h\"\n\n#include <iostream>\n\nint main() {\n    rpc::client c(\"localhost\", 8080);\n\n    std::string text;\n    while (std::getline(std::cin, text)) {\n        if (!text.empty()) {\n            std::string result(c.call(\"echo\", text).as<std::string>());\n            std::cout << \"> \" <<  result << std::endl;\n        }\n    }\n}",
            "title": "Home"
        },
        {
            "location": "/#rpclib-modern-msgpack-rpc-for-c",
            "text": "Welcome to the documentation of  rpclib !  rpclib  is a msgpack-rpc implementation written using modern C++. The goal of this library is to provide a simple, no-nonsense RPC solution.",
            "title": "rpclib - modern msgpack-rpc for C++"
        },
        {
            "location": "/#documentation",
            "text": "Getting started : Requirements, installation - everything you need to be able to start using  rpclib  Primer : A longer tutorial introduction to using the library, intended for newcomers  Cookbook : Recipes for common tasks the library was designed for handling, in the form of short examples  Building : Basic and advanced building options.  Glossary : Collection of definitions used by the library.  Reference : Complete reference of the  rpclib  API.  MsgPack-RPC specification : The specification of the Msgpack-RPC protocol, as  rpclib  implements it  Roadmap : Planned features",
            "title": "Documentation"
        },
        {
            "location": "/#what-does-it-look-like",
            "text": "Here is a very simple example, a kind of hello world for network-related libraries:  #include \"rpc/server.h\"\n\nint main() {\n    rpc::server srv(8080);\n\n    srv.bind(\"echo\", [](std::string const& s) {\n        return s;\n    });\n\n    srv.run();\n    return 0;\n}  #include \"rpc/client.h\"\n\n#include <iostream>\n\nint main() {\n    rpc::client c(\"localhost\", 8080);\n\n    std::string text;\n    while (std::getline(std::cin, text)) {\n        if (!text.empty()) {\n            std::string result(c.call(\"echo\", text).as<std::string>());\n            std::cout << \"> \" <<  result << std::endl;\n        }\n    }\n}",
            "title": "What does it look like?"
        },
        {
            "location": "/gettingstarted/",
            "text": "Getting started\n\n\nThis document details the steps of getting everything in place to be able to use \nrpclib\n.\n\n\nWhat you need\n\n\nCompiler\n\n\nrpclib\n uses some C++14 features, and as such, requires a recent compiler. The following compilers are tried and tested with \nrpclib\n at the moment:\n\n\n\n\ng++ 5.0\n\n\nclang++ 3.7\n\n\nMSVC 2015 Update 2\n\n\n\n\nNewer versions of these compilers are expected to work.\n\n\nTools\n\n\nIn addition to a capable compiler, you will need:\n\n\n\n\nCMake 3.x\n\n\nAnd either\n\n\nGNU make, or\n\n\nNinja, or\n\n\nMSBuild/Visual Studio (on Microsoft Windows).\n\n\n\n\n\n\n\n\nThe library\n\n\nThere are various release packages available for the most popular systems and ideally you should install one of those. If there is no suitable package for your system or you simply prefer to build from source, take a look at the \nCompiling\n chapter.\n\n\n\n\nInfo\n\n\nrpclib\n uses CMake and has a very conventional build process. If you know how to build a CMake-based library, you know how to build \nrpclib\n.\n\n\n\n\nDependencies\n\n\nrpclib\n has no external library dependencies, i.e. you don't need to install any extra libraries to use it. The library does use third-party code, but it is hidden both during compilation and linking (i.e. it means you don't need to worry about linking against those same libraries).\n\n\n\n\nTip\n\n\nSee the \nDesign\n documentation for details on how \nrpclib\n handles its dependencies.\n\n\n\n\nSetting up your environment\n\n\nIn order to use \nrpclib\n in your projects, you will need to have it built and stored somewhere on your system. Place the \nrpclib\n headers into your include path, and link the static library with your executable. The exact process of that depends on your compiler and/or IDE.\n\n\nWhere to go from here\n\n\nNow that you have an environment where you can compile and link programs with \nrpclib\n, either\ncheck out the \nPrimer\n for a step-by-step tutorial or the \nCookbook\n, if you prefer short examples with minimal instructions.",
            "title": "Getting started"
        },
        {
            "location": "/gettingstarted/#getting-started",
            "text": "This document details the steps of getting everything in place to be able to use  rpclib .",
            "title": "Getting started"
        },
        {
            "location": "/gettingstarted/#what-you-need",
            "text": "",
            "title": "What you need"
        },
        {
            "location": "/gettingstarted/#compiler",
            "text": "rpclib  uses some C++14 features, and as such, requires a recent compiler. The following compilers are tried and tested with  rpclib  at the moment:   g++ 5.0  clang++ 3.7  MSVC 2015 Update 2   Newer versions of these compilers are expected to work.",
            "title": "Compiler"
        },
        {
            "location": "/gettingstarted/#tools",
            "text": "In addition to a capable compiler, you will need:   CMake 3.x  And either  GNU make, or  Ninja, or  MSBuild/Visual Studio (on Microsoft Windows).",
            "title": "Tools"
        },
        {
            "location": "/gettingstarted/#the-library",
            "text": "There are various release packages available for the most popular systems and ideally you should install one of those. If there is no suitable package for your system or you simply prefer to build from source, take a look at the  Compiling  chapter.   Info  rpclib  uses CMake and has a very conventional build process. If you know how to build a CMake-based library, you know how to build  rpclib .",
            "title": "The library"
        },
        {
            "location": "/gettingstarted/#dependencies",
            "text": "rpclib  has no external library dependencies, i.e. you don't need to install any extra libraries to use it. The library does use third-party code, but it is hidden both during compilation and linking (i.e. it means you don't need to worry about linking against those same libraries).   Tip  See the  Design  documentation for details on how  rpclib  handles its dependencies.",
            "title": "Dependencies"
        },
        {
            "location": "/gettingstarted/#setting-up-your-environment",
            "text": "In order to use  rpclib  in your projects, you will need to have it built and stored somewhere on your system. Place the  rpclib  headers into your include path, and link the static library with your executable. The exact process of that depends on your compiler and/or IDE.",
            "title": "Setting up your environment"
        },
        {
            "location": "/gettingstarted/#where-to-go-from-here",
            "text": "Now that you have an environment where you can compile and link programs with  rpclib , either\ncheck out the  Primer  for a step-by-step tutorial or the  Cookbook , if you prefer short examples with minimal instructions.",
            "title": "Where to go from here"
        },
        {
            "location": "/primer/",
            "text": "Primer\n\n\nWelcome to the Primer! This document is a tutorial introduction to \nrpclib\n for absolute beginners. If you are new to the library and prefer detailed instructions and explanation, you are in the right place. If short examples with less explanation work better for you, you might want to check out the \nCookbook\n!\n\n\nThe tutorial is sturctured as follows: in the first part, writing servers is explained with one simple and one more advanced example.  In the second part, the corresponding clients are implemented.\n\n\nPrerequisites\n\n\nKnowledge-wise, this tutorial assumes that you have an intermediate grasp of C++ and that you have an idea of what \nRPC\n (Remote Procedure Call) is.\n\n\nFor your build environment, make sure that you are able to compile and link a program with\n\nrpclib\n. The \nGetting Started\n page can help you with that.\n\n\nIntroduction\n\n\nrpclib\n is a RPC library that provides both a \nclient\n and a \nserver\n implementation. The \nserver\n allows you to expose functions of your program to be called remotely, while the \nclient\n allows you to call functions of servers. You can use the \nrpclib\n client and server in tandem (even in the same program, if you want to), but it's not a requirement.\n\n\nAs other RPC libraries, \nrpclib\n is a good candidate for inter-process communication. Also, there exist many implementations of the protocol in a large amount of languages, which makes it a possible inter-language communication bridge.\n\n\nmsgpack-RPC is the protocol that \nrpclib\n uses for dispatching and encoding calls to functions. The protocol is based on \nmsgpack\n, a fast and compact format. For details on how exactly it is structured, see the \nSpecification\n chapter.\n\n\nWriting servers\n\n\nIn the first part of this tutorial, we will learn about writing server applications. Two example\napplications will be implemented step-by-step.\n\n\nCalculator, the \"Hello World\" of RPC libraries.\n\n\nOur first server application will expose four functions: \nadd\n, \nsubtract\n, \nmultiply\n, \ndivide\n. For the sake of this example, the functions are implemented as various callable entities.\n\n\n#include \"rpc/server.h\"\n\ndouble divide(double a, double b) { return a / b; }\n\nstruct subtractor {\n    double operator()(double a, double b) { return a - b; }\n};\n\nstruct multiplier {\n    double multiply(double a, double b) { return a * b; }\n};\n\nint main() {\n    subtractor s;\n    multiplier m;\n    auto add = [](double a, double b) { return a + b; };\n\n    // ...\n\n    return 0;\n}\n\n\n\n\n\nNow, let's create the server:\n\n\nrpc::server srv(8080);\n\n\n\n\nThis server will listen on port 8080 (but not right away after construction - we need to \nrun\n it). Next, we \nbind\n the functors to names in order to expose them:\n\n\nsrv.bind(\"add\", [](double a, double b) { return a + b; });\nsrv.bind(\"sub\", s);\nsrv.bind(\"div\", &divide);\nsrv.bind(\"mul\", [&m](double a, double b) { return m.multiply(a, b); });\n\n\n\n\nThese are the names that the client can use to call our functions. There is nothing stopping you from binding \ndivide\n to the name \n\"add\"\n, but it's a good practice to use names that reflect the source names. It is also possible to bind the same function to multiple names.\n\n\n\n\nInfo\n\n\nUnder the hood, each \nbind\n statement generates a compile-time a wrapper function that takes a \nmsgpack\n object, then decodes it into the real parameters of the bound function (if any) and calls the bound function. If the function has a return value the wrapper is generated so that it encodes the result as a \nmsgpack\n object which the server can send to the client in a response. More information on this mechanism can be found in the \nDesign\n chapter.\n\n\n\n\nAfter we exposed the function, we need to \nrun\n the server:\n\n\nsrv.run();\n\n\n\n\nrun\n is a blocking function, but it also has a non-blocking pair called \nasync_run\n. When \nrun\n is called, the server starts listening on the port we assigned to it in its constructor, and its internal event loop will start processing the incoming requests.\n\n\nThis is now a functioning (although, in some ways, incomplete) server. The complete listing so far:\n\n\n#include \"rpc/server.h\"\n\ndouble divide(double a, double b) { return a / b; }\n\nstruct subtractor {\n    double operator()(double a, double b) { return a - b; }\n};\n\nstruct multiplier {\n    double multiply(double a, double b) { return a * b; }\n};\n\nint main() {\n    rpc::server srv(8080);\n\n    subtractor s;\n    multiplier m;\n\n    srv.bind(\"add\", [](double a, double b) { return a + b; });\n    srv.bind(\"sub\", s);\n    srv.bind(\"div\", &divide);\n    srv.bind(\"mul\", [&m](double a, double b) { return m.multiply(a, b); });\n\n    srv.run();\n\n    return 0;\n}\n\n\n\n\nIf you want, you can fire up a \nquick python script\n to test it (don't worry, we'll write a client with \nrpclib\n, too).\n\n\nResponding with errors\n\n\nThere is, however, an issue with this server. Did you spot it? Any client can easily make it crash just by calling \ndiv\n with a 0 divider (causing division by zero). What can we do about this? Well of course, we can just check the divider and \nnot\n perform the division. We still need to return \nsomething\n though:\n\n\n#include \"rpc/server.h\"\n\ndouble divide(double a, double b) {\n    if (b == 0) {\n        return 0.0; // <- ugh, that's not very good :S\n    }\n    return a / b;\n}\n\n\n\n\nThis is enough to avoid the crash, but it's fundamentally broken: division by zero does not yield zero, after all. The client gets an arbitrary result (oblivious to the fact that there was an error), which is most likely not what they want.\n\n\nLuckily, the msgpack-rpc protocol supports error signaling. We need to modify our \ndivide\n function a little bit to utilize this functionality:\n\n\n#include \"rpc/server.h\"\n#include \"rpc/this_handler.h\"\n\ndouble divide(double a, double b) {\n    if (b == 0) {\n        rpc::this_handler().respond_error(\"Division by zero\");\n    }\n    return a / b;\n}\n\n\n\n\nThis is better. The error is \nstringly-typed\n, but it's\nbetter than an arbitrary result. To amend this, we can return practically any object, such as\na tuple that contains an error code besides the message:\n\n\ndouble divide(double a, double b) {\n    if (b == 0.0) {\n        rpc::this_handler().respond_error(\n                std::make_tuple(1, \"Division by zero\"));\n    }\n    return a / b;\n}\n\n\n\n\n\n\nInfo\n\n\nmsgpack-rpc\n does not define the structure of error objects, so making up something like this is\nperfectly fine (in fact, I'd encourage you to do this with well-defined error codes). Consider\nit part of your server interface and document accordingly.\n\n\n\n\nYou might be puzzled about why we are not returning after setting the error. The reason for this is that \nrespond_error\n throws an internal exception that is handled inside the library. (\nThis can be considered an implementation detail, but it's good to know what happens here (and it's unlikely to change\n).\n\n\nNow, with the added error handling, our server is bullet-proof. Or is it?\n\n\nWhat about \nmy\n exceptions?\n\n\nOur little calculator server is pretty stable at this point, but real-world applications often have to deal with exceptions. In general, exceptions should be handled at the library users' discretion (that is, caught on the handler level). So by default, \nrpclib\n doesn't do anything with them. If an exception leaves the handler, it is an unhandled exception and your server will crash. Yet, there are cases when you can't or don't want to handle exceptions in the handler. To facilitate this, \nrpclib\n provides a way to automatically turn exceptions into RPC errors:\n\n\nsrv.suppress_exceptions(true);\n\n\n\n\nWith this, you can call functions that throw or throw exceptions:\n\n\ndouble divide(double a, double b) {\n    if (b == 0) {\n        rpc::this_handler().respond_error(\n                std::make_tuple(1, \"Division by zero\"));\n    }\n    else if (b == 1) {\n        throw std::runtime_error(\"Come on!\");\n    }\n    throw std::logic_error(\"What am I doing here?\");\n}\n\n\n\n\nSo yes, this means that if you set \nsuppress_excpetions\n to \ntrue\n, you might as well signal errors from handlers by throwing exceptions. Be advised that \nrespond_error\n is still valid and remains the preferred way to do so (especially that it's the only way to respond with structured error objects). \n\n\nWhat exactly happens to the suppressed exception? \nrpclib\n will try to catch \nstd::exceptions\n and use their \nwhat()\n members to get a string representation which it sets as an error.\n\n\nWhat if you throw something that is not a \nstd::exception\n-descendant? First of all, shame on you. Second, \nrpclib\n will send an error message letting your clients know that you threw something that is not a \nstd::exception\n (\nshaming you in front of your clients\n). Don't do this, really.\n\n\nA more complicated server - Parallel mandelbrot-generation\n\n\nThe following example demonstrates parallel processing and binding custom data types. The server itself will have two functions: one for getting the current date and time, and one for getting a rendering of the mandelbrot set. The two functions can be called asynchronously by a client.\n\n\nUsing custom types as parameters\n\n\nAnything that msgpack can process can be used as a parameter or return value for a bound function. In order to teach msgpack about your custom types, you need to use the \nMSGPACK_DEFINE_ARRAY\n or \nMSGPACK_DEFINE_MAP\n macros.\n\n\n\n\nInfo\n\n\nThe difference between the two macros is that the array only contains the data values after each other, while the map also contains the names of the values. The latter gives more flexibility, the former is more compact.\n\n\n\n\nIn our mandelbrot example, we will want to send pixel data to the clients, so let's define a struct:\n\n\nstruct pixel {\n    unsigned char r, g, b;\n    MSGPACK_DEFINE_ARRAY(r, g, b)\n};\n\nusing pixel_data = std::vector<pixel>;\n\n\n\n\nWe will share this definition between the client and server, so for our purposes it's best to put it in a common header.\n\n\nLike in the first example, we create the server and bind the functions we expose. This time we are using lambdas as the bound functions.\n\n\nrpc::server srv(8080);\n\nsrv.bind(\"get_time\", []() {\n    time_t rawtime;\n    struct tm *timeinfo;\n    time (&rawtime);\n    timeinfo = localtime(&rawtime);\n    return asctime(timeinfo);\n});\n\nsrv.bind(\"get_mandelbrot\", [&](int width, int height) {\n    pixel_data data;\n    for (int x = 0; x < width; x++) {\n        for (int y = 0; y < height; y++) {\n            // ...\n        }\n    }\n\n    return data;\n});\n\n\n\n\nThe exact contents of these functions is not a concern for our purposes, just note that the \nget_time\n returns a value very quickly, while \nget_mandelbrot\n computes a large array of numbers for several seconds.\n\n\nRunning the server asynchrously and utilizing workers\n\n\nIn the first example, we called the blocking \nrun\n function of the server to start it. Here, we are going to use \nasync_run\n. There are two important differences.\n\n\n. \nrun\n blocks, \nasync_run\n returns after starting the server.\n. \nasync_run\n supports spawning worker threads for executing the bound functions.\n\n\nIn this example, we call it like this:\n\n\nsrv.async_run(2);\n\n\n\n\nThis will spawn two worker threads in the server (so now there are three in the program, because the main thread already exists). The threads will wait until there is work to do.\n\n\n\n\nInfo\n\n\n\"Work\" is not only executing handlers. Processing network I/O is also part of the work that threads can take. You don't need an extra thread per connection though, because processing the I/O is typically not very processor-intensive.\n\n\n\n\nNow this server can take a call to \nget_mandelbrot\n, start executing it and in the meantime it can finish multiple \nget_time\n calls. The handlers are only executed by these worker threads, the main thread is free to continue.\n\n\nWriting clients\n\n\nCreating msgpack-rpc clients with \nrpclib\n happens very similarly to servers. Mirroring the server examples above, we will implement their corresponding clients.\n\n\nThe Calculator client\n\n\nThe \nclient\n object is instantiated like this:\n\n\nrpc::client client(\"127.0.0.1\", 8080);\n\n\n\n\nThe important difference, compared to a server, is that we also need to specify the host to connect to.\n\n\nAnother difference is that the client tries to connect to the server right away during construction (but the construction of the client is not a blocking call). The client object can be used right away:\n\n\ndouble five = c.call(\"add\", 2, 3).as<double>();\n\n\n\n\nLet's try and call all of the exposed functions. With a little bit of logging to the standard\noutput, the complete listing looks like this so far:\n\n\n#include <iostream>\n\n#include \"rpc/client.h\"\n\nint main() {\n    rpc::client c(\"localhost\", 8080);\n\n    std::cout << \"add(2, 3) = \";\n    double five = c.call(\"add\", 2, 3).as<double>();\n    std::cout << five << std::endl;\n\n    std::cout << \"sub(3, 2) = \";\n    double one = c.call(\"sub\", 3, 2).as<double>();\n    std::cout << one << std::endl;\n\n    std::cout << \"mul(5, 0) = \";\n    double zero = c.call(\"mul\", five, 0).as<double>();\n    std::cout << zero << std::endl;\n\n    std::cout << \"div(3, 0) = \";\n    double hmm = c.call(\"div\", 3, 0).as<double>();\n    std::cout << hmm << std::endl;\n\n    return 0;\n}\n\n\n\n\nError handling\n\n\nAny request that a client makes might potentially receive an error response. In the calculator server, we decided to respond with a \ntuple\n containing an error code and a message. \nrpclib\n allows you to handle these error objects by catching \nrpc::rpc_error\n exceptions. To handle the errors the server throws, we would wrap the calls like this:\n\n\ntry {\n    std::cout << \"add(2, 3) = \";\n    double five = c.call(\"add\", 2, 3).as<double>();\n    std::cout << five << std::endl;\n\n    std::cout << \"sub(3, 2) = \";\n    double one = c.call(\"sub\", 3, 2).as<double>();\n    std::cout << one << std::endl;\n\n    std::cout << \"mul(5, 0) = \";\n    double zero = c.call(\"mul\", five, 0).as<double>();\n    std::cout << zero << std::endl;\n\n    std::cout << \"div(3, 0) = \";\n    double hmm = c.call(\"div\", 3, 0).as<double>();\n    std::cout << hmm << std::endl;\n} catch (rpc::rpc_error &e) {\n    std::cout << std::endl << e.what() << std::endl;\n    std::cout << \"in function \" << e.get_function_name() << \": \";\n\n    using err_t = std::tuple<int, std::string>;\n    auto err = e.get_error().as<err_t>();\n    std::cout << \"[error \" << std::get<0>(err) << \"]: \" << std::get<1>(err)\n              << std::endl;\n    return 1;\n}\n\n\n\n\nAs you would expect, the output looks like this:\n\n\nadd(2, 3) = 5\nsub(3, 2) = 1\nmul(5, 0) = 0\ndiv(3, 0) = \nrpclib: a handler responded with an error\nin function 'div': [error 1]: Division by zero\n\n\n\n\nThat's pretty much all we need for the calculator client.\n\n\nThe anatomy of a \ncall\n\n\ncall\n does a couple of things:\n\n\n\n\nIf the client is not yet connected to the server, it waits until it connects (this might block until the connection is established)\n\n\nSends a \"call\" message to the server\n\n\nWaits for the response and returns it as a msgpack object - this blocks until the response is read.\n\n\n\n\nIn the example above, you can see how getting a strongly typed value from the result is done: using the \nas\n member template. This takes the msgpack object and tries to deserialize it into the type given. If that fails, you will get a \ntype_error\n.\n\n\ncall\n takes at least one parameter (the name of the function to call), and an arbitrary number and type of other paramters that are meant to be passed to the function being called. Each parameter has to be serializable by msgpack.\n\n\n\n\nTip\n\n\nSee \nmsgpack adaptors\n from the msgpack documentation for more information on serializing and deserializing custom types.\n\n\n\n\nThe Mandelbrot client\n\n\nThe client for the mandelbrot server above is interesting because we will take advantage of the multiple workers in the server. In order to do that, instead of \ncall\n we are going to use \nasync_call\n.\n\n\nasync_call\n is very similar to \ncall\n, but it does not wait for the response. Instead, it will return a \nfuture\n, allowing us to continue our program flow and retrieve the result later (which the server can compute in the meantime).\n\n\nrpc::client c(\"127.0.0.1\", 8080);\n\n// this returns immediately:\nauto result_obj = c.async_call(\"get_mandelbrot\", width, height);\n\n// we can now call another function and wait for its result:\nauto current_time = c.call(\"get_time\").as<std::string>();\n\n// ... after some time, retrieve the result (optionally wait for it)\nauto result = result_obj.get().as<pixel_data>();\n\n\n\n\nThe call to \nget_time\n can be performed with \ncall\n (no need for \nasync_call\n), because the other call is running on a different worker.\n\n\n\n\nInfo\n\n\nWhat would happen if our server only had one worker thread?\n We would get the same output, but with more delay: The server would only start processing the \nget_time\n call after it finished executing and writing the response of \nget_mandelbrot\n. Essentially, a single-threaded server works in a \"queue\" fashion. The same thing would happen if the server was simple under heavy load.\n\n\n\n\nAsync servers vs. async clients vs. parallel execution\n\n\nDoes the asynchonous nature of \nasync_call\n depend on the server or the load of the server then? No, it does not. It's important to realize that \nasync_call\n is still asynchronous even if the server does not execute requests in parallel. If there are multiple clients connected to the server, their requests are processed in a more queued manner (still two requests processed at the same time).\n\n\n\n\nTip\n\n\nrpclib\n uses a simple convention: \nfoo\n is a synchronous call, \nasync_foo\n is asynchronous. This conventions was adapted from Asio. The latter only means that the call returns \"immediately\" (or rather, very quickly and without finishing all of the work).\n\n\n\n\nThe two worker threads in the mandelbrot server can serve two clients in parallel. Or two calls of the same client, which happens in the example. In order to be able to send two requests in an interleaved fashion, we first use \nasync_call\n which allows the control flow of the client to continue.\n\n\nWhere to go from here\n\n\nThe \nCookbook\n features most (if not all) intended use cases of rpclib - it's a great\nplace to continue. \n\n\nIf you are interested in the internal design of \nrpclib\n, take a look at the \nDesign\n\npage.",
            "title": "Primer"
        },
        {
            "location": "/primer/#primer",
            "text": "Welcome to the Primer! This document is a tutorial introduction to  rpclib  for absolute beginners. If you are new to the library and prefer detailed instructions and explanation, you are in the right place. If short examples with less explanation work better for you, you might want to check out the  Cookbook !  The tutorial is sturctured as follows: in the first part, writing servers is explained with one simple and one more advanced example.  In the second part, the corresponding clients are implemented.",
            "title": "Primer"
        },
        {
            "location": "/primer/#prerequisites",
            "text": "Knowledge-wise, this tutorial assumes that you have an intermediate grasp of C++ and that you have an idea of what  RPC  (Remote Procedure Call) is.  For your build environment, make sure that you are able to compile and link a program with rpclib . The  Getting Started  page can help you with that.",
            "title": "Prerequisites"
        },
        {
            "location": "/primer/#introduction",
            "text": "rpclib  is a RPC library that provides both a  client  and a  server  implementation. The  server  allows you to expose functions of your program to be called remotely, while the  client  allows you to call functions of servers. You can use the  rpclib  client and server in tandem (even in the same program, if you want to), but it's not a requirement.  As other RPC libraries,  rpclib  is a good candidate for inter-process communication. Also, there exist many implementations of the protocol in a large amount of languages, which makes it a possible inter-language communication bridge.  msgpack-RPC is the protocol that  rpclib  uses for dispatching and encoding calls to functions. The protocol is based on  msgpack , a fast and compact format. For details on how exactly it is structured, see the  Specification  chapter.",
            "title": "Introduction"
        },
        {
            "location": "/primer/#writing-servers",
            "text": "In the first part of this tutorial, we will learn about writing server applications. Two example\napplications will be implemented step-by-step.",
            "title": "Writing servers"
        },
        {
            "location": "/primer/#calculator-the-hello-world-of-rpc-libraries",
            "text": "Our first server application will expose four functions:  add ,  subtract ,  multiply ,  divide . For the sake of this example, the functions are implemented as various callable entities.  #include \"rpc/server.h\"\n\ndouble divide(double a, double b) { return a / b; }\n\nstruct subtractor {\n    double operator()(double a, double b) { return a - b; }\n};\n\nstruct multiplier {\n    double multiply(double a, double b) { return a * b; }\n};\n\nint main() {\n    subtractor s;\n    multiplier m;\n    auto add = [](double a, double b) { return a + b; };\n\n    // ...\n\n    return 0;\n}  Now, let's create the server:  rpc::server srv(8080);  This server will listen on port 8080 (but not right away after construction - we need to  run  it). Next, we  bind  the functors to names in order to expose them:  srv.bind(\"add\", [](double a, double b) { return a + b; });\nsrv.bind(\"sub\", s);\nsrv.bind(\"div\", &divide);\nsrv.bind(\"mul\", [&m](double a, double b) { return m.multiply(a, b); });  These are the names that the client can use to call our functions. There is nothing stopping you from binding  divide  to the name  \"add\" , but it's a good practice to use names that reflect the source names. It is also possible to bind the same function to multiple names.   Info  Under the hood, each  bind  statement generates a compile-time a wrapper function that takes a  msgpack  object, then decodes it into the real parameters of the bound function (if any) and calls the bound function. If the function has a return value the wrapper is generated so that it encodes the result as a  msgpack  object which the server can send to the client in a response. More information on this mechanism can be found in the  Design  chapter.   After we exposed the function, we need to  run  the server:  srv.run();  run  is a blocking function, but it also has a non-blocking pair called  async_run . When  run  is called, the server starts listening on the port we assigned to it in its constructor, and its internal event loop will start processing the incoming requests.  This is now a functioning (although, in some ways, incomplete) server. The complete listing so far:  #include \"rpc/server.h\"\n\ndouble divide(double a, double b) { return a / b; }\n\nstruct subtractor {\n    double operator()(double a, double b) { return a - b; }\n};\n\nstruct multiplier {\n    double multiply(double a, double b) { return a * b; }\n};\n\nint main() {\n    rpc::server srv(8080);\n\n    subtractor s;\n    multiplier m;\n\n    srv.bind(\"add\", [](double a, double b) { return a + b; });\n    srv.bind(\"sub\", s);\n    srv.bind(\"div\", &divide);\n    srv.bind(\"mul\", [&m](double a, double b) { return m.multiply(a, b); });\n\n    srv.run();\n\n    return 0;\n}  If you want, you can fire up a  quick python script  to test it (don't worry, we'll write a client with  rpclib , too).",
            "title": "Calculator, the \"Hello World\" of RPC libraries."
        },
        {
            "location": "/primer/#responding-with-errors",
            "text": "There is, however, an issue with this server. Did you spot it? Any client can easily make it crash just by calling  div  with a 0 divider (causing division by zero). What can we do about this? Well of course, we can just check the divider and  not  perform the division. We still need to return  something  though:  #include \"rpc/server.h\"\n\ndouble divide(double a, double b) {\n    if (b == 0) {\n        return 0.0; // <- ugh, that's not very good :S\n    }\n    return a / b;\n}  This is enough to avoid the crash, but it's fundamentally broken: division by zero does not yield zero, after all. The client gets an arbitrary result (oblivious to the fact that there was an error), which is most likely not what they want.  Luckily, the msgpack-rpc protocol supports error signaling. We need to modify our  divide  function a little bit to utilize this functionality:  #include \"rpc/server.h\"\n#include \"rpc/this_handler.h\"\n\ndouble divide(double a, double b) {\n    if (b == 0) {\n        rpc::this_handler().respond_error(\"Division by zero\");\n    }\n    return a / b;\n}  This is better. The error is  stringly-typed , but it's\nbetter than an arbitrary result. To amend this, we can return practically any object, such as\na tuple that contains an error code besides the message:  double divide(double a, double b) {\n    if (b == 0.0) {\n        rpc::this_handler().respond_error(\n                std::make_tuple(1, \"Division by zero\"));\n    }\n    return a / b;\n}   Info  msgpack-rpc  does not define the structure of error objects, so making up something like this is\nperfectly fine (in fact, I'd encourage you to do this with well-defined error codes). Consider\nit part of your server interface and document accordingly.   You might be puzzled about why we are not returning after setting the error. The reason for this is that  respond_error  throws an internal exception that is handled inside the library. ( This can be considered an implementation detail, but it's good to know what happens here (and it's unlikely to change ).  Now, with the added error handling, our server is bullet-proof. Or is it?",
            "title": "Responding with errors"
        },
        {
            "location": "/primer/#what-about-my-exceptions",
            "text": "Our little calculator server is pretty stable at this point, but real-world applications often have to deal with exceptions. In general, exceptions should be handled at the library users' discretion (that is, caught on the handler level). So by default,  rpclib  doesn't do anything with them. If an exception leaves the handler, it is an unhandled exception and your server will crash. Yet, there are cases when you can't or don't want to handle exceptions in the handler. To facilitate this,  rpclib  provides a way to automatically turn exceptions into RPC errors:  srv.suppress_exceptions(true);  With this, you can call functions that throw or throw exceptions:  double divide(double a, double b) {\n    if (b == 0) {\n        rpc::this_handler().respond_error(\n                std::make_tuple(1, \"Division by zero\"));\n    }\n    else if (b == 1) {\n        throw std::runtime_error(\"Come on!\");\n    }\n    throw std::logic_error(\"What am I doing here?\");\n}  So yes, this means that if you set  suppress_excpetions  to  true , you might as well signal errors from handlers by throwing exceptions. Be advised that  respond_error  is still valid and remains the preferred way to do so (especially that it's the only way to respond with structured error objects).   What exactly happens to the suppressed exception?  rpclib  will try to catch  std::exceptions  and use their  what()  members to get a string representation which it sets as an error.  What if you throw something that is not a  std::exception -descendant? First of all, shame on you. Second,  rpclib  will send an error message letting your clients know that you threw something that is not a  std::exception  ( shaming you in front of your clients ). Don't do this, really.",
            "title": "What about my exceptions?"
        },
        {
            "location": "/primer/#a-more-complicated-server-parallel-mandelbrot-generation",
            "text": "The following example demonstrates parallel processing and binding custom data types. The server itself will have two functions: one for getting the current date and time, and one for getting a rendering of the mandelbrot set. The two functions can be called asynchronously by a client.",
            "title": "A more complicated server - Parallel mandelbrot-generation"
        },
        {
            "location": "/primer/#using-custom-types-as-parameters",
            "text": "Anything that msgpack can process can be used as a parameter or return value for a bound function. In order to teach msgpack about your custom types, you need to use the  MSGPACK_DEFINE_ARRAY  or  MSGPACK_DEFINE_MAP  macros.   Info  The difference between the two macros is that the array only contains the data values after each other, while the map also contains the names of the values. The latter gives more flexibility, the former is more compact.   In our mandelbrot example, we will want to send pixel data to the clients, so let's define a struct:  struct pixel {\n    unsigned char r, g, b;\n    MSGPACK_DEFINE_ARRAY(r, g, b)\n};\n\nusing pixel_data = std::vector<pixel>;  We will share this definition between the client and server, so for our purposes it's best to put it in a common header.  Like in the first example, we create the server and bind the functions we expose. This time we are using lambdas as the bound functions.  rpc::server srv(8080);\n\nsrv.bind(\"get_time\", []() {\n    time_t rawtime;\n    struct tm *timeinfo;\n    time (&rawtime);\n    timeinfo = localtime(&rawtime);\n    return asctime(timeinfo);\n});\n\nsrv.bind(\"get_mandelbrot\", [&](int width, int height) {\n    pixel_data data;\n    for (int x = 0; x < width; x++) {\n        for (int y = 0; y < height; y++) {\n            // ...\n        }\n    }\n\n    return data;\n});  The exact contents of these functions is not a concern for our purposes, just note that the  get_time  returns a value very quickly, while  get_mandelbrot  computes a large array of numbers for several seconds.",
            "title": "Using custom types as parameters"
        },
        {
            "location": "/primer/#running-the-server-asynchrously-and-utilizing-workers",
            "text": "In the first example, we called the blocking  run  function of the server to start it. Here, we are going to use  async_run . There are two important differences.  .  run  blocks,  async_run  returns after starting the server.\n.  async_run  supports spawning worker threads for executing the bound functions.  In this example, we call it like this:  srv.async_run(2);  This will spawn two worker threads in the server (so now there are three in the program, because the main thread already exists). The threads will wait until there is work to do.   Info  \"Work\" is not only executing handlers. Processing network I/O is also part of the work that threads can take. You don't need an extra thread per connection though, because processing the I/O is typically not very processor-intensive.   Now this server can take a call to  get_mandelbrot , start executing it and in the meantime it can finish multiple  get_time  calls. The handlers are only executed by these worker threads, the main thread is free to continue.",
            "title": "Running the server asynchrously and utilizing workers"
        },
        {
            "location": "/primer/#writing-clients",
            "text": "Creating msgpack-rpc clients with  rpclib  happens very similarly to servers. Mirroring the server examples above, we will implement their corresponding clients.",
            "title": "Writing clients"
        },
        {
            "location": "/primer/#the-calculator-client",
            "text": "The  client  object is instantiated like this:  rpc::client client(\"127.0.0.1\", 8080);  The important difference, compared to a server, is that we also need to specify the host to connect to.  Another difference is that the client tries to connect to the server right away during construction (but the construction of the client is not a blocking call). The client object can be used right away:  double five = c.call(\"add\", 2, 3).as<double>();  Let's try and call all of the exposed functions. With a little bit of logging to the standard\noutput, the complete listing looks like this so far:  #include <iostream>\n\n#include \"rpc/client.h\"\n\nint main() {\n    rpc::client c(\"localhost\", 8080);\n\n    std::cout << \"add(2, 3) = \";\n    double five = c.call(\"add\", 2, 3).as<double>();\n    std::cout << five << std::endl;\n\n    std::cout << \"sub(3, 2) = \";\n    double one = c.call(\"sub\", 3, 2).as<double>();\n    std::cout << one << std::endl;\n\n    std::cout << \"mul(5, 0) = \";\n    double zero = c.call(\"mul\", five, 0).as<double>();\n    std::cout << zero << std::endl;\n\n    std::cout << \"div(3, 0) = \";\n    double hmm = c.call(\"div\", 3, 0).as<double>();\n    std::cout << hmm << std::endl;\n\n    return 0;\n}",
            "title": "The Calculator client"
        },
        {
            "location": "/primer/#error-handling",
            "text": "Any request that a client makes might potentially receive an error response. In the calculator server, we decided to respond with a  tuple  containing an error code and a message.  rpclib  allows you to handle these error objects by catching  rpc::rpc_error  exceptions. To handle the errors the server throws, we would wrap the calls like this:  try {\n    std::cout << \"add(2, 3) = \";\n    double five = c.call(\"add\", 2, 3).as<double>();\n    std::cout << five << std::endl;\n\n    std::cout << \"sub(3, 2) = \";\n    double one = c.call(\"sub\", 3, 2).as<double>();\n    std::cout << one << std::endl;\n\n    std::cout << \"mul(5, 0) = \";\n    double zero = c.call(\"mul\", five, 0).as<double>();\n    std::cout << zero << std::endl;\n\n    std::cout << \"div(3, 0) = \";\n    double hmm = c.call(\"div\", 3, 0).as<double>();\n    std::cout << hmm << std::endl;\n} catch (rpc::rpc_error &e) {\n    std::cout << std::endl << e.what() << std::endl;\n    std::cout << \"in function \" << e.get_function_name() << \": \";\n\n    using err_t = std::tuple<int, std::string>;\n    auto err = e.get_error().as<err_t>();\n    std::cout << \"[error \" << std::get<0>(err) << \"]: \" << std::get<1>(err)\n              << std::endl;\n    return 1;\n}  As you would expect, the output looks like this:  add(2, 3) = 5\nsub(3, 2) = 1\nmul(5, 0) = 0\ndiv(3, 0) = \nrpclib: a handler responded with an error\nin function 'div': [error 1]: Division by zero  That's pretty much all we need for the calculator client.",
            "title": "Error handling"
        },
        {
            "location": "/primer/#the-anatomy-of-a-call",
            "text": "call  does a couple of things:   If the client is not yet connected to the server, it waits until it connects (this might block until the connection is established)  Sends a \"call\" message to the server  Waits for the response and returns it as a msgpack object - this blocks until the response is read.   In the example above, you can see how getting a strongly typed value from the result is done: using the  as  member template. This takes the msgpack object and tries to deserialize it into the type given. If that fails, you will get a  type_error .  call  takes at least one parameter (the name of the function to call), and an arbitrary number and type of other paramters that are meant to be passed to the function being called. Each parameter has to be serializable by msgpack.   Tip  See  msgpack adaptors  from the msgpack documentation for more information on serializing and deserializing custom types.",
            "title": "The anatomy of a call"
        },
        {
            "location": "/primer/#the-mandelbrot-client",
            "text": "The client for the mandelbrot server above is interesting because we will take advantage of the multiple workers in the server. In order to do that, instead of  call  we are going to use  async_call .  async_call  is very similar to  call , but it does not wait for the response. Instead, it will return a  future , allowing us to continue our program flow and retrieve the result later (which the server can compute in the meantime).  rpc::client c(\"127.0.0.1\", 8080);\n\n// this returns immediately:\nauto result_obj = c.async_call(\"get_mandelbrot\", width, height);\n\n// we can now call another function and wait for its result:\nauto current_time = c.call(\"get_time\").as<std::string>();\n\n// ... after some time, retrieve the result (optionally wait for it)\nauto result = result_obj.get().as<pixel_data>();  The call to  get_time  can be performed with  call  (no need for  async_call ), because the other call is running on a different worker.   Info  What would happen if our server only had one worker thread?  We would get the same output, but with more delay: The server would only start processing the  get_time  call after it finished executing and writing the response of  get_mandelbrot . Essentially, a single-threaded server works in a \"queue\" fashion. The same thing would happen if the server was simple under heavy load.",
            "title": "The Mandelbrot client"
        },
        {
            "location": "/primer/#async-servers-vs-async-clients-vs-parallel-execution",
            "text": "Does the asynchonous nature of  async_call  depend on the server or the load of the server then? No, it does not. It's important to realize that  async_call  is still asynchronous even if the server does not execute requests in parallel. If there are multiple clients connected to the server, their requests are processed in a more queued manner (still two requests processed at the same time).   Tip  rpclib  uses a simple convention:  foo  is a synchronous call,  async_foo  is asynchronous. This conventions was adapted from Asio. The latter only means that the call returns \"immediately\" (or rather, very quickly and without finishing all of the work).   The two worker threads in the mandelbrot server can serve two clients in parallel. Or two calls of the same client, which happens in the example. In order to be able to send two requests in an interleaved fashion, we first use  async_call  which allows the control flow of the client to continue.",
            "title": "Async servers vs. async clients vs. parallel execution"
        },
        {
            "location": "/primer/#where-to-go-from-here",
            "text": "The  Cookbook  features most (if not all) intended use cases of rpclib - it's a great\nplace to continue.   If you are interested in the internal design of  rpclib , take a look at the  Design \npage.",
            "title": "Where to go from here"
        },
        {
            "location": "/cookbook/",
            "text": "Cookbook\n\n\nWelcome to the Cookbook! This is a collection of short examples that allows you to quickly learn\nthe ins and outs of \nrpclib\n. This guide is written in the spirit of \"less talk and more code\" (it's mostly only the titles, but also look out for the comments, they contain important information).\nIf you prefer detailed instructions and explanation, you might want to start with the\n\nPrimer\n.\n\n\nServer examples\n\n\nCreating a server\n\n\n#include \"rpc/server.h\"\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n\n    srv.run(); // blocking call\n    return 0;\n}\n\n\n\n\nBinding (exposing) free functions\n\n\n#include \"rpc/server.h\"\n#include <iostream>\n\nvoid foo() {\n    std::cout << \"Hey, I'm a free function.\" << std::endl;\n}\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n\n    srv.bind(\"foo\", &foo);\n\n    srv.run(); // blocking call, handlers run on this thread.\n    return 0;\n}\n\n\n\n\nBinding lambdas\n\n\n#include \"rpc/server.h\"\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n\n    srv.bind(\"hl3\", []() { \n        std::cout << \"Hey, I'm a lambda!\" << std::endl; \n    });\n\n    srv.run(); // blocking call\n    return 0;\n}\n\n\n\n\nBinding member functions\n\n\nConsider this class:\n\n\nclass foo_class {\npublic:\n    void quaz() {\n        std::cout << \"Hey, I'm a member function!\" << std::endl;\n    }\n};\n\n\n\n\nVersion 1: Binding through a lambda (preferred)\n\n\n#include \"rpc/server.h\"\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n    foo_class foo_obj;\n\n    srv.bind(\"quaz\", [&foo_obj](){ foo_obj.quaz(); }); \n\n    srv.run(); // blocking call\n\n    // NOTE: you have to make sure that the lifetime of foo_obj \n    // exceeds that of the server.\n\n    return 0;\n}\n\n\n\n\nVersion 2: using \nstd::bind\n\n\n#include <functional>\n\n#include \"rpc/server.h\"\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n    foo_class foo_obj;\n\n    std::function<void()> functor{std::bind(&foo_class::quaz, &foo_obj)};\n\n    srv.bind(\"quaz\", functor);\n\n    srv.run(); // blocking call\n\n    // NOTE: you have to make sure that the lifetime of foo_obj \n    // exceeds that of the server.\n\n    return 0;\n}\n\n\n\n\nMultiple worker threads\n\n\n#include \"rpc/server.h\"\n#include <iostream>\n\nvoid foo() {\n    std::cout << \"Hey, I'm a free function.\" << std::endl;\n}\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n\n    srv.bind(\"foo\", &foo);\n\n    constexpr size_t thread_count = 8;\n\n    srv.async_run(thread_count); // non-blocking call, handlers execute on one of the workers\n\n    std::cin.ignore();\n    return 0;\n}\n\n\n\n\nBinding using custom types\n\n\n#include \"rpc/server.h\"\n\nstruct custom_type {\n    int x;\n    double y;\n    std::string str;\n    MSGPACK_DEFINE_ARRAY(x, y, str); // or MSGPACK_DEFINE_MAP\n};\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n\n    srv.bind(\"cool_function\", [](custom_type const& c) {\n        std::cout << \"c = { \" << c.x << \", \"\n                  << c.y << \", \" << c.str << \"}\" << std::endl;\n    });\n\n    srv.run(); // blocking call\n    return 0;\n}\n\n\n\n\nResponding with errors\n\n\n#include \"rpc/server.h\"\n#include \"rpc/this_handler.h\"\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n\n    srv.bind(\"error\", []() { \n        auto err_obj = std::make_tuple(13, \"Errors are arbitrary objects\");\n        rpc::this_handler().respond_error(err_obj);\n    });\n\n    srv.run(); // blocking call\n    return 0;\n}\n\n\n\n\nResponding with arbitrary objects\n\n\nEven though C++ isn't, \nmsgpack-rpc\n is very lenient on types. Your client might be implemented in\na dynamic language.\n\n\n#include \"rpc/server.h\"\n#include \"rpc/this_handler.h\"\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n\n    srv.bind(\"oh\", [](bool quirky) -> std::string { \n        if (quirky) {\n            rpc::this_handler().respond(5);\n        }\n        return \"I'm not quirky.\";\n    });\n\n    srv.run(); // blocking call\n    return 0;\n}\n\n\n\n\nDisabling response\n\n\nThis prevents the server from ever writing a response to a particular call.\n\n\n#include \"rpc/server.h\"\n#include \"rpc/this_handler.h\"\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n\n    srv.bind(\"plz_respond\", [](bool nice) {\n        if (nice) {\n            rpc::this_handler().disable_response();\n        }\n        return \"ok\";\n    });\n\n    srv.run(); // blocking call\n    return 0;\n}\n\n\n\n\nExiting a session\n\n\nA session represents a client connection on the server. All ongoing writes and reads are completed first.\n\n\n#include \"rpc/server.h\"\n#include \"rpc/this_session.h\"\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n\n    srv.bind(\"exit\", []() {\n        rpc::this_session().post_exit(); // post exit to the queue\n    });\n\n    srv.run(); // blocking call\n    return 0;\n}\n\n\n\n\npost_exit\n will add exiting the session as a work item to the queue. This means that exiting is\nnot instantenous. The TCP connection will be closed gracefully.\n\n\nStopping a server\n\n\nTo gracefully stop all sessions on the server. All ongoing writes and reads are completed first.\n\n\n#include \"rpc/server.h\"\n#include \"rpc/this_server.h\"\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n\n    srv.bind(\"stop_server\", []() {\n        rpc::this_server().stop();\n    });\n\n    srv.run(); // blocking call\n    return 0;\n}\n\n\n\n\nClient examples\n\n\nCreating a client\n\n\n#include \"rpc/client.h\"\n\nint main() {\n    rpc::client c(\"127.0.0.1\", 8080);\n\n    // client initiates async connection upon creation\n    return 0;\n\n    // destructor of client disconnects\n}\n\n\n\n\nCalling functions\n\n\n#include \"rpc/client.h\"\n\nint main() {\n    rpc::client c(\"127.0.0.1\", 8080);\n\n    // client initiates async connection upon creation\n\n    // call blocks until:\n    // - connection is established\n    // - result is read\n    c.call(\"foo\", 2, 3.3, \"str\"); \n\n    return 0;\n}\n\n\n\n\nGetting return values\n\n\n#include \"rpc/client.h\"\n\nint main() {\n    rpc::client c(\"127.0.0.1\", 8080);\n    int a = c.call(\"add\", 2, 3).as<int>(); \n\n    return 0;\n}\n\n\n\n\nCalling functions asynchronously\n\n\n#include \"rpc/client.h\"\n\nint main() {\n    rpc::client c(\"127.0.0.1\", 8080);\n\n    auto a_future = c.async_call(\"add\", 2, 3); // non-blocking, returns std::future\n\n    std::cout << \"I can do something here immediately\" << std::endl;\n\n    int a = a_future.get().as<int>(); // possibly blocks if the result is not yet available\n\n    return 0;\n}\n\n\n\n\nQuerying the connection state\n\n\n#include \"rpc/client.h\"\n\nint main() {\n    rpc::client c(\"127.0.0.1\", 8080);\n    client::connection_state cs = c.get_connection_state();\n\n    return 0;\n}\n\n\n\n\nCalling a function with a timeout\n\n\n#include <chrono>\n#include \"rpc/client.h\"\n\nint main() {\n    using namespace std::chrono_literals;\n    rpc::client c(\"127.0.0.1\", 8080);\n\n    auto f = c.async_call(\"long_func\"); // non-blocking, returns std::future\n\n    if (f.wait_for(50ms) == std::future_status::timeout) {\n        std::cout << \"Oh no, the call timed out!\" << std::endl;\n        // it's possible to wait more here\n    }\n    else {\n        std::cout << \"Oh yes, the call finished in time!\" << std::endl;\n        // future::get() wiil already have the result at this point\n    }\n\n    return 0;\n}\n\n\n\n\nWhere to go from here\n\n\nIf you want to know even more about \nrpclib\n, look behind the abstractions in the \nDesign\n chapter which explains the internal workings and design decisions.",
            "title": "Cookbook"
        },
        {
            "location": "/cookbook/#cookbook",
            "text": "Welcome to the Cookbook! This is a collection of short examples that allows you to quickly learn\nthe ins and outs of  rpclib . This guide is written in the spirit of \"less talk and more code\" (it's mostly only the titles, but also look out for the comments, they contain important information).\nIf you prefer detailed instructions and explanation, you might want to start with the Primer .",
            "title": "Cookbook"
        },
        {
            "location": "/cookbook/#server-examples",
            "text": "",
            "title": "Server examples"
        },
        {
            "location": "/cookbook/#creating-a-server",
            "text": "#include \"rpc/server.h\"\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n\n    srv.run(); // blocking call\n    return 0;\n}",
            "title": "Creating a server"
        },
        {
            "location": "/cookbook/#binding-exposing-free-functions",
            "text": "#include \"rpc/server.h\"\n#include <iostream>\n\nvoid foo() {\n    std::cout << \"Hey, I'm a free function.\" << std::endl;\n}\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n\n    srv.bind(\"foo\", &foo);\n\n    srv.run(); // blocking call, handlers run on this thread.\n    return 0;\n}",
            "title": "Binding (exposing) free functions"
        },
        {
            "location": "/cookbook/#binding-lambdas",
            "text": "#include \"rpc/server.h\"\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n\n    srv.bind(\"hl3\", []() { \n        std::cout << \"Hey, I'm a lambda!\" << std::endl; \n    });\n\n    srv.run(); // blocking call\n    return 0;\n}",
            "title": "Binding lambdas"
        },
        {
            "location": "/cookbook/#binding-member-functions",
            "text": "Consider this class:  class foo_class {\npublic:\n    void quaz() {\n        std::cout << \"Hey, I'm a member function!\" << std::endl;\n    }\n};",
            "title": "Binding member functions"
        },
        {
            "location": "/cookbook/#version-1-binding-through-a-lambda-preferred",
            "text": "#include \"rpc/server.h\"\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n    foo_class foo_obj;\n\n    srv.bind(\"quaz\", [&foo_obj](){ foo_obj.quaz(); }); \n\n    srv.run(); // blocking call\n\n    // NOTE: you have to make sure that the lifetime of foo_obj \n    // exceeds that of the server.\n\n    return 0;\n}",
            "title": "Version 1: Binding through a lambda (preferred)"
        },
        {
            "location": "/cookbook/#version-2-using-stdbind",
            "text": "#include <functional>\n\n#include \"rpc/server.h\"\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n    foo_class foo_obj;\n\n    std::function<void()> functor{std::bind(&foo_class::quaz, &foo_obj)};\n\n    srv.bind(\"quaz\", functor);\n\n    srv.run(); // blocking call\n\n    // NOTE: you have to make sure that the lifetime of foo_obj \n    // exceeds that of the server.\n\n    return 0;\n}",
            "title": "Version 2: using std::bind"
        },
        {
            "location": "/cookbook/#multiple-worker-threads",
            "text": "#include \"rpc/server.h\"\n#include <iostream>\n\nvoid foo() {\n    std::cout << \"Hey, I'm a free function.\" << std::endl;\n}\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n\n    srv.bind(\"foo\", &foo);\n\n    constexpr size_t thread_count = 8;\n\n    srv.async_run(thread_count); // non-blocking call, handlers execute on one of the workers\n\n    std::cin.ignore();\n    return 0;\n}",
            "title": "Multiple worker threads"
        },
        {
            "location": "/cookbook/#binding-using-custom-types",
            "text": "#include \"rpc/server.h\"\n\nstruct custom_type {\n    int x;\n    double y;\n    std::string str;\n    MSGPACK_DEFINE_ARRAY(x, y, str); // or MSGPACK_DEFINE_MAP\n};\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n\n    srv.bind(\"cool_function\", [](custom_type const& c) {\n        std::cout << \"c = { \" << c.x << \", \"\n                  << c.y << \", \" << c.str << \"}\" << std::endl;\n    });\n\n    srv.run(); // blocking call\n    return 0;\n}",
            "title": "Binding using custom types"
        },
        {
            "location": "/cookbook/#responding-with-errors",
            "text": "#include \"rpc/server.h\"\n#include \"rpc/this_handler.h\"\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n\n    srv.bind(\"error\", []() { \n        auto err_obj = std::make_tuple(13, \"Errors are arbitrary objects\");\n        rpc::this_handler().respond_error(err_obj);\n    });\n\n    srv.run(); // blocking call\n    return 0;\n}",
            "title": "Responding with errors"
        },
        {
            "location": "/cookbook/#responding-with-arbitrary-objects",
            "text": "Even though C++ isn't,  msgpack-rpc  is very lenient on types. Your client might be implemented in\na dynamic language.  #include \"rpc/server.h\"\n#include \"rpc/this_handler.h\"\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n\n    srv.bind(\"oh\", [](bool quirky) -> std::string { \n        if (quirky) {\n            rpc::this_handler().respond(5);\n        }\n        return \"I'm not quirky.\";\n    });\n\n    srv.run(); // blocking call\n    return 0;\n}",
            "title": "Responding with arbitrary objects"
        },
        {
            "location": "/cookbook/#disabling-response",
            "text": "This prevents the server from ever writing a response to a particular call.  #include \"rpc/server.h\"\n#include \"rpc/this_handler.h\"\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n\n    srv.bind(\"plz_respond\", [](bool nice) {\n        if (nice) {\n            rpc::this_handler().disable_response();\n        }\n        return \"ok\";\n    });\n\n    srv.run(); // blocking call\n    return 0;\n}",
            "title": "Disabling response"
        },
        {
            "location": "/cookbook/#exiting-a-session",
            "text": "A session represents a client connection on the server. All ongoing writes and reads are completed first.  #include \"rpc/server.h\"\n#include \"rpc/this_session.h\"\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n\n    srv.bind(\"exit\", []() {\n        rpc::this_session().post_exit(); // post exit to the queue\n    });\n\n    srv.run(); // blocking call\n    return 0;\n}  post_exit  will add exiting the session as a work item to the queue. This means that exiting is\nnot instantenous. The TCP connection will be closed gracefully.",
            "title": "Exiting a session"
        },
        {
            "location": "/cookbook/#stopping-a-server",
            "text": "To gracefully stop all sessions on the server. All ongoing writes and reads are completed first.  #include \"rpc/server.h\"\n#include \"rpc/this_server.h\"\n\nint main() {\n    rpc::server srv(8080); // listen on TCP port 8080\n\n    srv.bind(\"stop_server\", []() {\n        rpc::this_server().stop();\n    });\n\n    srv.run(); // blocking call\n    return 0;\n}",
            "title": "Stopping a server"
        },
        {
            "location": "/cookbook/#client-examples",
            "text": "",
            "title": "Client examples"
        },
        {
            "location": "/cookbook/#creating-a-client",
            "text": "#include \"rpc/client.h\"\n\nint main() {\n    rpc::client c(\"127.0.0.1\", 8080);\n\n    // client initiates async connection upon creation\n    return 0;\n\n    // destructor of client disconnects\n}",
            "title": "Creating a client"
        },
        {
            "location": "/cookbook/#calling-functions",
            "text": "#include \"rpc/client.h\"\n\nint main() {\n    rpc::client c(\"127.0.0.1\", 8080);\n\n    // client initiates async connection upon creation\n\n    // call blocks until:\n    // - connection is established\n    // - result is read\n    c.call(\"foo\", 2, 3.3, \"str\"); \n\n    return 0;\n}",
            "title": "Calling functions"
        },
        {
            "location": "/cookbook/#getting-return-values",
            "text": "#include \"rpc/client.h\"\n\nint main() {\n    rpc::client c(\"127.0.0.1\", 8080);\n    int a = c.call(\"add\", 2, 3).as<int>(); \n\n    return 0;\n}",
            "title": "Getting return values"
        },
        {
            "location": "/cookbook/#calling-functions-asynchronously",
            "text": "#include \"rpc/client.h\"\n\nint main() {\n    rpc::client c(\"127.0.0.1\", 8080);\n\n    auto a_future = c.async_call(\"add\", 2, 3); // non-blocking, returns std::future\n\n    std::cout << \"I can do something here immediately\" << std::endl;\n\n    int a = a_future.get().as<int>(); // possibly blocks if the result is not yet available\n\n    return 0;\n}",
            "title": "Calling functions asynchronously"
        },
        {
            "location": "/cookbook/#querying-the-connection-state",
            "text": "#include \"rpc/client.h\"\n\nint main() {\n    rpc::client c(\"127.0.0.1\", 8080);\n    client::connection_state cs = c.get_connection_state();\n\n    return 0;\n}",
            "title": "Querying the connection state"
        },
        {
            "location": "/cookbook/#calling-a-function-with-a-timeout",
            "text": "#include <chrono>\n#include \"rpc/client.h\"\n\nint main() {\n    using namespace std::chrono_literals;\n    rpc::client c(\"127.0.0.1\", 8080);\n\n    auto f = c.async_call(\"long_func\"); // non-blocking, returns std::future\n\n    if (f.wait_for(50ms) == std::future_status::timeout) {\n        std::cout << \"Oh no, the call timed out!\" << std::endl;\n        // it's possible to wait more here\n    }\n    else {\n        std::cout << \"Oh yes, the call finished in time!\" << std::endl;\n        // future::get() wiil already have the result at this point\n    }\n\n    return 0;\n}",
            "title": "Calling a function with a timeout"
        },
        {
            "location": "/cookbook/#where-to-go-from-here",
            "text": "If you want to know even more about  rpclib , look behind the abstractions in the  Design  chapter which explains the internal workings and design decisions.",
            "title": "Where to go from here"
        },
        {
            "location": "/glossary/",
            "text": "Glossary\n\n\nThis is a collection of terms used in the documentation and API of rpclib. \n\n\n\n\n\n\n\n\nTerm\n\n\nDefinition\n\n\n\n\n\n\n\n\n\n\nServer\n\n\nA program that acts as an RPC endpoint receiving calls.\n\n\n\n\n\n\nClient\n\n\nA program that connects to Servers and calls their bound functions.\n\n\n\n\n\n\nBinding\n\n\nExposing a functor of the Server with a name\n\n\n\n\n\n\nHandler\n\n\nA bound function\n\n\n\n\n\n\nWorker\n\n\nA thread that performes work in the Server.",
            "title": "Glossary"
        },
        {
            "location": "/glossary/#glossary",
            "text": "This is a collection of terms used in the documentation and API of rpclib.      Term  Definition      Server  A program that acts as an RPC endpoint receiving calls.    Client  A program that connects to Servers and calls their bound functions.    Binding  Exposing a functor of the Server with a name    Handler  A bound function    Worker  A thread that performes work in the Server.",
            "title": "Glossary"
        },
        {
            "location": "/compiling/",
            "text": "Compiling \nrpclib\n\n\nCompiling \nrpclib\n is a fairly normal and unsurprising experience if you have used cmake-based projects. This document details the advanced building options as well as building the documentation which you might find useful if you want to reproduce everything locally.\n\n\nDefault configuration\n\n\nThe default configuration is the one intended for end-users. If you want to hack on \nrpclib\n, you might be interested in some of the Advanced options.\n\n\nUnix-type systems\n\n\nThis includes most (all?) Linux distributions and cygwin. Building \nrpclib\n is very similar to other cmake-based projects:\n\n\ngit clone git@github.com:rpclib/rpclib.git\ncd rpc\nmkdir build && cd build\ncmake ..\nmake\n\n\n\n\nAnd that's it. If all goes well, your build output will be in the \noutput\n directory.\n\n\nMicrosoft Windows\n\n\nOn Windows with MSVC it is very similar, except you will probably want to\n\n\ngit clone git@github.com:sztomi/rpc.git\ncd rpc\nmkdir build && cd build\ncmake ..\n\n\n\n\n... and open the generated solution file in Visual Studio or build it using msbuild.\n\n\nAdvanced options\n\n\nThere are some compilation options that affect the build output. These options can be set using ccmake, cmake-gui or on the cmake command line.\n\n\n\n\n\n\n\n\nName\n\n\nDefault value\n\n\nUsage\n\n\n\n\n\n\n\n\n\n\nRPCLIB_BUILD_TESTS\n\n\nOFF\n\n\nBuilds the unit tests of the library. You might want to turn this on if you are using an unreleased version.\n\n\n\n\n\n\nRPCLIB_GENERATE_COMPDB\n\n\nOFF\n\n\nGenerates a json compilation database for use with clang-based tools (such as clang-tidy, YCM etc.)\n\n\n\n\n\n\nRPCLIB_BUILD_EXAMPLES\n\n\nON\n\n\nBuilds the collection of example programs that demonstrate the features of \nrpclib\n.\n\n\n\n\n\n\nRPCLIB_ENABLE_LOGGING\n\n\nOFF\n\n\nEnables the internal logging of \nrpclib\n. This slightly affects performance. Currently the logging is not very configurable (for example, everything goes to stdout), but there are plans to make it easier to integrate with your application. Use this feature for debugging purposes.\n\n\n\n\n\n\nRPCLIB_ENABLE_COVERAGE\n\n\nOFF\n\n\nThis enables passing the code coverage generation flag when building with g++. It is used on Travis to provide coverage monitoring in tandem with Coveralls.io.\n\n\n\n\n\n\nRPCLIB_FORCE_M64\n\n\nOFF\n\n\nForce -m64 for g++ and clang++. Your build tools must support cross-compilation if this is not your native environment.\n\n\n\n\n\n\nRPCLIB_FORCE_M32\n\n\nOFF\n\n\nForce -m32 for g++ and clang++. Your build tools must support cross-compilation if this is not your native environment.",
            "title": "Compiling"
        },
        {
            "location": "/compiling/#compiling-rpclib",
            "text": "Compiling  rpclib  is a fairly normal and unsurprising experience if you have used cmake-based projects. This document details the advanced building options as well as building the documentation which you might find useful if you want to reproduce everything locally.",
            "title": "Compiling rpclib"
        },
        {
            "location": "/compiling/#default-configuration",
            "text": "The default configuration is the one intended for end-users. If you want to hack on  rpclib , you might be interested in some of the Advanced options.",
            "title": "Default configuration"
        },
        {
            "location": "/compiling/#unix-type-systems",
            "text": "This includes most (all?) Linux distributions and cygwin. Building  rpclib  is very similar to other cmake-based projects:  git clone git@github.com:rpclib/rpclib.git\ncd rpc\nmkdir build && cd build\ncmake ..\nmake  And that's it. If all goes well, your build output will be in the  output  directory.",
            "title": "Unix-type systems"
        },
        {
            "location": "/compiling/#microsoft-windows",
            "text": "On Windows with MSVC it is very similar, except you will probably want to  git clone git@github.com:sztomi/rpc.git\ncd rpc\nmkdir build && cd build\ncmake ..  ... and open the generated solution file in Visual Studio or build it using msbuild.",
            "title": "Microsoft Windows"
        },
        {
            "location": "/compiling/#advanced-options",
            "text": "There are some compilation options that affect the build output. These options can be set using ccmake, cmake-gui or on the cmake command line.     Name  Default value  Usage      RPCLIB_BUILD_TESTS  OFF  Builds the unit tests of the library. You might want to turn this on if you are using an unreleased version.    RPCLIB_GENERATE_COMPDB  OFF  Generates a json compilation database for use with clang-based tools (such as clang-tidy, YCM etc.)    RPCLIB_BUILD_EXAMPLES  ON  Builds the collection of example programs that demonstrate the features of  rpclib .    RPCLIB_ENABLE_LOGGING  OFF  Enables the internal logging of  rpclib . This slightly affects performance. Currently the logging is not very configurable (for example, everything goes to stdout), but there are plans to make it easier to integrate with your application. Use this feature for debugging purposes.    RPCLIB_ENABLE_COVERAGE  OFF  This enables passing the code coverage generation flag when building with g++. It is used on Travis to provide coverage monitoring in tandem with Coveralls.io.    RPCLIB_FORCE_M64  OFF  Force -m64 for g++ and clang++. Your build tools must support cross-compilation if this is not your native environment.    RPCLIB_FORCE_M32  OFF  Force -m32 for g++ and clang++. Your build tools must support cross-compilation if this is not your native environment.",
            "title": "Advanced options"
        },
        {
            "location": "/design/",
            "text": "Design",
            "title": "Internal design"
        },
        {
            "location": "/design/#design",
            "text": "",
            "title": "Design"
        },
        {
            "location": "/spec/",
            "text": "MessagePack-RPC Protocol specification\n\n\nThis specification was copied from https://github.com/msgpack-rpc/msgpack-rpc/blob/master/spec.md\n(without the \"sales pitch\" part). Also slightly edited to make things clearer and clean up typos.\n\n\nThe protocol consists of a request message and the corresponding response message or a notification message (without a response). The server must send a response message in reply with the request message.\n\n\nRequest message\n\n\nThe request message is a four-element array, shown below.\n\n\n[type, msgid, method, params]\n\n\n\n\ntype\n\n\nMust be zero (integer). Zero means that this message is the request message.\n\n\nmsgid\n\n\nThe 32-bit unsigned integer number. This number is used as a sequence number. The server replies with a requested msgid.\n\n\nmethod\n\n\nThe string, which represents the method name to call.\n\n\nparams\n\n\nThe array of the function arguments. The elements of this array are arbitrary objects. If the\nfunction takes no arguments, this is an empty array (not \nnil\n).\n\n\nResponse message\n\n\nThe response message is a four-element array, shown below.\n\n\n[type, msgid, error, result]\n\n\n\n\ntype\n\n\nMust be one (integer). One means that this message is the response message.\n\n\nmsgid\n\n\nThe 32-bit unsigned integer number. This corresponds to the msgid of the request message.\n\n\nerror\n\n\nIf the method is executed correctly, this field should be \nnil\n. If the error occurred at the server-side, then this field is an arbitrary object which represents the error.\n\n\nresult\n\n\nAn arbitrary object, which represents the returned result of the function. If an error occurred, this field should be \nnil\n.\n\n\nNotification message\n\n\nThe notification message is a three-element array, shown below.\n\n\n[type, method, params]\n\n\n\n\ntype\n\n\nMust be two (integer). Two means that this message is a notification message.\n\n\nmethod\n\n\nThe string, which represents the method name to call.\n\n\nparams\n\n\nThe array of the function arguments. The elements of this array are arbitrary objects. If the\nfunction takes no arguments, this is an empty array (not \nnil\n).\n\n\nThe order of responses\n\n\nThe server implementations don't have to send the responses in the order of receiveing the requests. If they receive the multiple messages, they may reply in any order.\n\n\nClient implementation details\n\n\nThere are some client features which a client library should implement.\n\n\nSynchronous calls\n\n\nThe client is blocked until the RPC is finished.\n\n\nClient client = new Client(\"localhost\", 1985);\nObject result = client.call(\"method_name\", arg1, arg2, arg3);\n\n\n\n\nAsynchronous calls\n\n\nThe following figure shows how asynchronous call works.\n\n\nThe the call function returns a \nfuture\n object immediately.\n\n\nClient client = new Client(\"localhost\", 1985);\nFuture future = client.asyncCall(\"method_name\", arg1, arg2, arg3);\nfuture.join();\nObject result = future.getResult();\n\n\n\n\nClient client = new Client(...);\nFuture f1 = client.asyncCall(\"method1\");\nFuture f2 = client.asyncCall(\"method2\");\nf1.join();\nf2.join();\n\n\n\n\nMultiple transports\n\n\nThe implementation should support multiple transports like TCP, UDP, UNIX domain socket if possible.",
            "title": "Specification"
        },
        {
            "location": "/spec/#messagepack-rpc-protocol-specification",
            "text": "This specification was copied from https://github.com/msgpack-rpc/msgpack-rpc/blob/master/spec.md\n(without the \"sales pitch\" part). Also slightly edited to make things clearer and clean up typos.  The protocol consists of a request message and the corresponding response message or a notification message (without a response). The server must send a response message in reply with the request message.",
            "title": "MessagePack-RPC Protocol specification"
        },
        {
            "location": "/spec/#request-message",
            "text": "The request message is a four-element array, shown below.  [type, msgid, method, params]",
            "title": "Request message"
        },
        {
            "location": "/spec/#type",
            "text": "Must be zero (integer). Zero means that this message is the request message.",
            "title": "type"
        },
        {
            "location": "/spec/#msgid",
            "text": "The 32-bit unsigned integer number. This number is used as a sequence number. The server replies with a requested msgid.",
            "title": "msgid"
        },
        {
            "location": "/spec/#method",
            "text": "The string, which represents the method name to call.",
            "title": "method"
        },
        {
            "location": "/spec/#params",
            "text": "The array of the function arguments. The elements of this array are arbitrary objects. If the\nfunction takes no arguments, this is an empty array (not  nil ).",
            "title": "params"
        },
        {
            "location": "/spec/#response-message",
            "text": "The response message is a four-element array, shown below.  [type, msgid, error, result]",
            "title": "Response message"
        },
        {
            "location": "/spec/#type_1",
            "text": "Must be one (integer). One means that this message is the response message.",
            "title": "type"
        },
        {
            "location": "/spec/#msgid_1",
            "text": "The 32-bit unsigned integer number. This corresponds to the msgid of the request message.",
            "title": "msgid"
        },
        {
            "location": "/spec/#error",
            "text": "If the method is executed correctly, this field should be  nil . If the error occurred at the server-side, then this field is an arbitrary object which represents the error.",
            "title": "error"
        },
        {
            "location": "/spec/#result",
            "text": "An arbitrary object, which represents the returned result of the function. If an error occurred, this field should be  nil .",
            "title": "result"
        },
        {
            "location": "/spec/#notification-message",
            "text": "The notification message is a three-element array, shown below.  [type, method, params]",
            "title": "Notification message"
        },
        {
            "location": "/spec/#type_2",
            "text": "Must be two (integer). Two means that this message is a notification message.",
            "title": "type"
        },
        {
            "location": "/spec/#method_1",
            "text": "The string, which represents the method name to call.",
            "title": "method"
        },
        {
            "location": "/spec/#params_1",
            "text": "The array of the function arguments. The elements of this array are arbitrary objects. If the\nfunction takes no arguments, this is an empty array (not  nil ).",
            "title": "params"
        },
        {
            "location": "/spec/#the-order-of-responses",
            "text": "The server implementations don't have to send the responses in the order of receiveing the requests. If they receive the multiple messages, they may reply in any order.",
            "title": "The order of responses"
        },
        {
            "location": "/spec/#client-implementation-details",
            "text": "There are some client features which a client library should implement.",
            "title": "Client implementation details"
        },
        {
            "location": "/spec/#synchronous-calls",
            "text": "The client is blocked until the RPC is finished.  Client client = new Client(\"localhost\", 1985);\nObject result = client.call(\"method_name\", arg1, arg2, arg3);",
            "title": "Synchronous calls"
        },
        {
            "location": "/spec/#asynchronous-calls",
            "text": "The following figure shows how asynchronous call works.  The the call function returns a  future  object immediately.  Client client = new Client(\"localhost\", 1985);\nFuture future = client.asyncCall(\"method_name\", arg1, arg2, arg3);\nfuture.join();\nObject result = future.getResult();  Client client = new Client(...);\nFuture f1 = client.asyncCall(\"method1\");\nFuture f2 = client.asyncCall(\"method2\");\nf1.join();\nf2.join();",
            "title": "Asynchronous calls"
        },
        {
            "location": "/spec/#multiple-transports",
            "text": "The implementation should support multiple transports like TCP, UDP, UNIX domain socket if possible.",
            "title": "Multiple transports"
        },
        {
            "location": "/reference/",
            "text": ".table td {\n        text-align: left;\n    }\n\n    .table td:first-child {\n        text-align: right;\n        width: 230px;\n    }\u200b\n\n\n\n\nReference\n\n\nThis document is a detailed and (hopefully) complete reference of the public interface of \nrpclib\n.\nFor a tutorial, take a look at the \nPrimer\n. Also, you can find many examples in the \nCookbook\n.\n\n\nrpc::client\n\n\n#include \"rpc/client.h\"\n\n\n\n\nDescription\n\n\nImplements a client that connects to a msgpack-rpc server and is able to call functions synchronously or asynchronously. This is the main interfacing point for implementing client applications. \n\n\nUse this class to connect to msgpack-rpc servers and call their exposed functions. This class supports calling functions synchronously and asynchronously. When the client object is created, it initiates connecting to the given server asynchronically and disconnects when it is destroyed. \n\n\nPublic functions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclient\n(std::string const &addr, uint16_t port)\n\n\n\n\n\n\n\n\n~client\n()\n\n\n\n\n\n\nmsgpack::object_handle\n\n\ncall\n(std::string const &func_name, Args...args)\n\n\n\n\n\n\nstd::future< msgpack::object_handle >\n\n\nasync_call\n(std::string const &func_name, Args...args)\n\n\n\n\n\n\nvoid\n\n\nsend\n(std::string const &func_name, Args...args)\n\n\n\n\n\n\nconnection_state\n\n\nget_connection_state\n() const\n\n\n\n\n\n\nvoid\n\n\nwait_all_responses\n()\n\n\n\n\n\n\n\n\nrpc::client::client\n\n\n\n rpc::client::client(std::string const &addr, uint16_t port);\n\n\n\n\nConstructs a client. \n\n\nParameters\n\n\naddr\n The address of the server to connect to. This might be an IP address or a host name, too. \n\n\nport\n The port on the server to connect to. \n\n\nDetails\n\n\nWhen a client is constructed, it initiates a connection asynchronically. This means that it will not block while the connection is established. However, when the first call is performed, it \nmight\n block if the connection was not already established.\n\n\nrpc::client::~client\n\n\n\n rpc::client::~client();\n\n\n\n\nDestructor. \n\n\nDetails\n\n\nDuring destruction, the connection to the server is gracefully closed. This means that any outstanding reads and writes are completed first. \n\n\nrpc::client::call\n\n\n\nmsgpack::object_handle rpc::client::call(std::string const &func_name, Args...args);\n\n\n\n\nCalls a function with the given name and arguments (if any). \n\n\nTemplate parameters\n\n\nArgs\n The types of the arguments. Each type in this parameter pack have to be serializable by msgpack.\n\n\nParameters\n\n\nfunc_name\n The name of the function to call on the server. \n\n\nargs\n A variable number of arguments to pass to the called function.\n\n\nReturn value\n\n\nA msgpack::object containing the result of the function (if any). To obtain a typed value, use the msgpack API.\n\n\nrpc::client::async_call\n\n\n\nstd::future< msgpack::object_handle > rpc::client::async_call(std::string const &func_name, Args...args);\n\n\n\n\nCalls a function asynchronously with the given name and arguments. \n\n\nTemplate parameters\n\n\nArgs\n The types of the arguments.\n\n\nParameters\n\n\nfunc_name\n The name of the function to call. \n\n\nargs\n The arguments to pass to the function.\n\n\nDetails\n\n\nA call is performed asynchronously in the context of the client, i.e. this is not to be confused with parallel execution on the server. This function differs from \ncall\n in that it does not wait for the result of the function. Instead, it returns a std::future that can be used to retrieve the result later.\n\n\nReturn value\n\n\nA std::future, possibly holding a future result (which is a msgpack::object). \n\n\nrpc::client::send\n\n\n\nvoid rpc::client::send(std::string const &func_name, Args...args);\n\n\n\n\nSends a notification with the given name and arguments (if any). \n\n\nTemplate parameters\n\n\nArgs\n The types of the arguments.\n\n\nParameters\n\n\nfunc_name\n The name of the notification to call. \n\n\nargs\n The arguments to pass to the function. \n\n\nDetails\n\n\nNotifications are a special kind of calls. They can be used to notify the server while not waiting for a response. In \nrpclib\n terminology, a notification is like an \nasync_call\n without a return value.\n\n\n\n\nWarn\n\n\nThis function returns immediately (possibly before the notification is written to the socket).\n\n\n\n\nrpc::client::get_connection_state\n\n\n\nconnection_state rpc::client::get_connection_state() const ;\n\n\n\n\nReturns the current connection state. \n\n\nrpc::client::wait_all_responses\n\n\n\nvoid rpc::client::wait_all_responses();\n\n\n\n\nWaits for the completion of all ongoing calls. \n\n\nrpc::rpc_error\n\n\n#include \"rpc/rpc_error.h\"\n\n\n\n\nDescription\n\n\nThis exception is thrown by the client when the server signals an error during a call. \n\n\nIt allows clients to handle arbitrary error objects as the msgpack-rpc specification allows. In client code you are not supposed to throw it, hence its constructor is private. \n\n\nPublic functions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstd::string\n\n\nget_function_name\n() const\n\n\n\n\n\n\nmsgpack::object_handle &\n\n\nget_error\n()\n\n\n\n\n\n\n\n\nrpc::rpc_error::get_function_name\n\n\n\nstd::string rpc::rpc_error::get_function_name() const ;\n\n\n\n\nReturns the name of the function that was called on the server while the error occurred. \n\n\nrpc::rpc_error::get_error\n\n\n\nmsgpack::object_handle & rpc::rpc_error::get_error();\n\n\n\n\nReturns the error object that the server provided. \n\n\nrpc::server\n\n\n#include \"rpc/server.h\"\n\n\n\n\nDescription\n\n\nImplements a msgpack-rpc server. This is the main interfacing point with the library for creating servers. \n\n\nThe server maintains a registry of function bindings that it uses to dispatch calls. It also takes care of managing worker threads and TCP connections. The server does not start listening right after construction in order to allow binding functions before that. Use the \nrun\n or \nasync_run\n functions to start listening on the port. \n\n\nPublic functions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nserver\n(uint16_t port)\n\n\n\n\n\n\n\n\nserver\n(std::string const &address, uint16_t port)\n\n\n\n\n\n\n\n\n~server\n()\n\n\n\n\n\n\nvoid\n\n\nrun\n()\n\n\n\n\n\n\nvoid\n\n\nasync_run\n(std::size_t worker_threads=1)\n\n\n\n\n\n\nvoid\n\n\nbind\n(std::string const &name, F func)\n\n\n\n\n\n\nvoid\n\n\nsuppress_exceptions\n(bool suppress)\n\n\n\n\n\n\nvoid\n\n\nstop\n()\n\n\n\n\n\n\nvoid\n\n\nclose_sessions\n()\n\n\n\n\n\n\n\n\nrpc::server::server\n\n\n\n rpc::server::server(uint16_t port);\n\n\n\n\nConstructs a server that listens on the localhost on the specified port. \n\n\nParameters\n\n\nport\n The port number to listen on. \n\n\nrpc::server::server\n\n\n\n rpc::server::server(std::string const &address, uint16_t port);\n\n\n\n\nConstructs a server that listens on the specified address on the specified port. \n\n\nParameters\n\n\nport\n The port number to listen on. \n\n\nrpc::server::~server\n\n\n\n rpc::server::~server();\n\n\n\n\nDestructor. \n\n\nDetails\n\n\nWhen the server is destroyed, all ongoin sessions are closed gracefully. \n\n\nrpc::server::run\n\n\n\nvoid rpc::server::run();\n\n\n\n\nStarts the server loop. This is a blocking call. \n\n\nDetails\n\n\nFirst and foremost, running the event loop causes the server to start listening on the specified port. Also, as connections are established and calls are made by clients, the server executes the calls as part of this call. This means that the handlers are executed on the thread that calls \nrun\n. Reads and writes are initiated by this function \n\n\nrpc::server::async_run\n\n\n\nvoid rpc::server::async_run(std::size_t worker_threads=1);\n\n\n\n\nStarts the server loop on one or more threads. This is a non-blocking call. \n\n\nParameters\n\n\nworker_threads\n The number of worker threads to start. \n\n\nDetails\n\n\nThis function behaves similarly to \nrun\n, except the event loop is optionally started on different threads. Effectively this sets up a worker thread pool for the server. Handlers will be executed on one of the threads.\n\n\nrpc::server::bind\n\n\n\nvoid rpc::server::bind(std::string const &name, F func);\n\n\n\n\nBinds a functor to a name so it becomes callable via RPC. \n\n\nTemplate parameters\n\n\nF\n The type of the functor. \n\n\nParameters\n\n\nname\n The name of the functor. \n\n\nfunc\n The functor to bind. \n\n\nDetails\n\n\nThis function template accepts a wide range of callables. The arguments and return types of these callables should be serializable by msgpack. \nbind\n effectively generates a suitable, light-weight compile-time wrapper for the functor.\n\n\nrpc::server::suppress_exceptions\n\n\n\nvoid rpc::server::suppress_exceptions(bool suppress);\n\n\n\n\nSets the exception behavior in handlers. By default, handlers throwing will crash the server. If suppressing is on, the server will try to gather textual data and return it to the client as an error response. \n\n\n\n\nWarn\n\n\nSetting this flag only affects subsequent connections. \n\n\n\n\nrpc::server::stop\n\n\n\nvoid rpc::server::stop();\n\n\n\n\nStops the server. \n\n\n\n\nWarn\n\n\nThis should not be called from worker threads. \n\n\n\n\nrpc::server::close_sessions\n\n\n\nvoid rpc::server::close_sessions();\n\n\n\n\nCloses all sessions gracefully. \n\n\nrpc::this_handler_t\n\n\n#include \"rpc/this_handler.h\"\n\n\n\n\nDescription\n\n\nEncapsulates information about the currently executing handler. This is the interface through which bound functions may return errors, arbitrary type responses or prohibit sending a response. \n\n\nTo obtain a \nthis_handler_t\n object that corresponds to the currently executing handler, use the \nrpc::this_handler()\n free function. Any changes performed through the \nthis_handler\n will only be in affect during the current call. It is safe to obtain multiple \nthis_handler\ns from concurrently executing handlers. Each object is unique to the current thread.\n\n\nPublic functions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid\n\n\nrespond_error\n(T &&err_obj)\n\n\n\n\n\n\nvoid\n\n\nrespond\n(T &&resp_obj)\n\n\n\n\n\n\nvoid\n\n\ndisable_response\n()\n\n\n\n\n\n\nvoid\n\n\nenable_response\n()\n\n\n\n\n\n\nvoid\n\n\nclear\n()\n\n\n\n\n\n\n\n\nrpc::this_handler_t::respond_error\n\n\n\nvoid rpc::this_handler_t::respond_error(T &&err_obj);\n\n\n\n\nSets an arbitrary object to be sent back as an error response to the client. \n\n\nTemplate parameters\n\n\nT\n The type of the error object. \n\n\nParameters\n\n\nerr_obj\n The error object. This can be anything that is possible to encode with messagepack (even custom structures). \n\n\nDetails\n\n\nInternally, this function throws an exception, i.e. the control flow is interrupted at the point of this call.\n\n\nrpc::this_handler_t::respond\n\n\n\nvoid rpc::this_handler_t::respond(T &&resp_obj);\n\n\n\n\nSets an arbitrary object to be sent back as the response to the call. \n\n\nTemplate parameters\n\n\nT\n The type of the response object. \n\n\nParameters\n\n\nresp_obj\n The response object. This can be anything that is possible to encode with messagepack (even custom structures). \n\n\nDetails\n\n\nInternally, this function throws an exception, i.e. the control flow is interrupted at the point of this call.\n\n\n\n\nWarn\n\n\nThe normal return value of the function (if any) will be ignored if a special response is set.\n\n\n\n\nrpc::this_handler_t::disable_response\n\n\n\nvoid rpc::this_handler_t::disable_response();\n\n\n\n\nInstructs the server to not send a response to the client (ignoring any errors and return values). \n\n\n\n\nWarn\n\n\nIt is unusual to not send a response to requests, and doing so might cause problems in the client (depending on its implementation). \n\n\n\n\nrpc::this_handler_t::enable_response\n\n\n\nvoid rpc::this_handler_t::enable_response();\n\n\n\n\nRe-enables sending a response to the call. Sending the response is by default enabled. Enabling the response multiple times have no effect. \n\n\nrpc::this_handler_t::clear\n\n\n\nvoid rpc::this_handler_t::clear();\n\n\n\n\nSets all state of the object to default. \n\n\nrpc::this_server_t\n\n\n#include \"rpc/this_server.h\"\n\n\n\n\nDescription\n\n\nAllows controlling the server instance from the currently executing handler. \n\n\nPublic functions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid\n\n\nstop\n()\n\n\n\n\n\n\nvoid\n\n\ncancel_stop\n()\n\n\n\n\n\n\n\n\nrpc::this_server_t::stop\n\n\n\nvoid rpc::this_server_t::stop();\n\n\n\n\nGracefully stops the server. \n\n\nDetails\n\n\nStopping only takes effect after leaving the handler normally. \n\n\nrpc::this_server_t::cancel_stop\n\n\n\nvoid rpc::this_server_t::cancel_stop();\n\n\n\n\nCancels a requested stop operation. \n\n\nrpc::this_session_t\n\n\n#include \"rpc/this_session.h\"\n\n\n\n\nDescription\n\n\nEncapsulates information about the server session/connection this handler is running in. This is the interface through which bound functions may interact with the session. \n\n\nA session represents a connection on the server that corresponds to a single client. \n\n\nPublic functions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid\n\n\npost_exit\n()\n\n\n\n\n\n\n\n\nrpc::this_session_t::post_exit\n\n\n\nvoid rpc::this_session_t::post_exit();\n\n\n\n\nGracefully exits the session (i.e. ongoing writes and reads are completed; queued writes and reads are not). \n\n\n\n\nWarn\n\n\nUse this function if you need to close the connection from a handler.",
            "title": "Reference"
        },
        {
            "location": "/reference/#reference",
            "text": "This document is a detailed and (hopefully) complete reference of the public interface of  rpclib .\nFor a tutorial, take a look at the  Primer . Also, you can find many examples in the  Cookbook .",
            "title": "Reference"
        },
        {
            "location": "/reference/#rpcclient",
            "text": "#include \"rpc/client.h\"",
            "title": "rpc::client"
        },
        {
            "location": "/reference/#description",
            "text": "Implements a client that connects to a msgpack-rpc server and is able to call functions synchronously or asynchronously. This is the main interfacing point for implementing client applications.   Use this class to connect to msgpack-rpc servers and call their exposed functions. This class supports calling functions synchronously and asynchronously. When the client object is created, it initiates connecting to the given server asynchronically and disconnects when it is destroyed.",
            "title": "Description"
        },
        {
            "location": "/reference/#public-functions",
            "text": "client (std::string const &addr, uint16_t port)     ~client ()    msgpack::object_handle  call (std::string const &func_name, Args...args)    std::future< msgpack::object_handle >  async_call (std::string const &func_name, Args...args)    void  send (std::string const &func_name, Args...args)    connection_state  get_connection_state () const    void  wait_all_responses ()",
            "title": "Public functions"
        },
        {
            "location": "/reference/#parameters",
            "text": "addr  The address of the server to connect to. This might be an IP address or a host name, too.   port  The port on the server to connect to.",
            "title": "Parameters"
        },
        {
            "location": "/reference/#details",
            "text": "When a client is constructed, it initiates a connection asynchronically. This means that it will not block while the connection is established. However, when the first call is performed, it  might  block if the connection was not already established.",
            "title": "Details"
        },
        {
            "location": "/reference/#details_1",
            "text": "During destruction, the connection to the server is gracefully closed. This means that any outstanding reads and writes are completed first.",
            "title": "Details"
        },
        {
            "location": "/reference/#template-parameters",
            "text": "Args  The types of the arguments. Each type in this parameter pack have to be serializable by msgpack.",
            "title": "Template parameters"
        },
        {
            "location": "/reference/#parameters_1",
            "text": "func_name  The name of the function to call on the server.   args  A variable number of arguments to pass to the called function.",
            "title": "Parameters"
        },
        {
            "location": "/reference/#return-value",
            "text": "A msgpack::object containing the result of the function (if any). To obtain a typed value, use the msgpack API.",
            "title": "Return value"
        },
        {
            "location": "/reference/#template-parameters_1",
            "text": "Args  The types of the arguments.",
            "title": "Template parameters"
        },
        {
            "location": "/reference/#parameters_2",
            "text": "func_name  The name of the function to call.   args  The arguments to pass to the function.",
            "title": "Parameters"
        },
        {
            "location": "/reference/#details_2",
            "text": "A call is performed asynchronously in the context of the client, i.e. this is not to be confused with parallel execution on the server. This function differs from  call  in that it does not wait for the result of the function. Instead, it returns a std::future that can be used to retrieve the result later.",
            "title": "Details"
        },
        {
            "location": "/reference/#return-value_1",
            "text": "A std::future, possibly holding a future result (which is a msgpack::object).",
            "title": "Return value"
        },
        {
            "location": "/reference/#template-parameters_2",
            "text": "Args  The types of the arguments.",
            "title": "Template parameters"
        },
        {
            "location": "/reference/#parameters_3",
            "text": "func_name  The name of the notification to call.   args  The arguments to pass to the function.",
            "title": "Parameters"
        },
        {
            "location": "/reference/#details_3",
            "text": "Notifications are a special kind of calls. They can be used to notify the server while not waiting for a response. In  rpclib  terminology, a notification is like an  async_call  without a return value.   Warn  This function returns immediately (possibly before the notification is written to the socket).",
            "title": "Details"
        },
        {
            "location": "/reference/#rpcrpc_error",
            "text": "#include \"rpc/rpc_error.h\"",
            "title": "rpc::rpc_error"
        },
        {
            "location": "/reference/#description_1",
            "text": "This exception is thrown by the client when the server signals an error during a call.   It allows clients to handle arbitrary error objects as the msgpack-rpc specification allows. In client code you are not supposed to throw it, hence its constructor is private.",
            "title": "Description"
        },
        {
            "location": "/reference/#public-functions_1",
            "text": "std::string  get_function_name () const    msgpack::object_handle &  get_error ()",
            "title": "Public functions"
        },
        {
            "location": "/reference/#rpcserver",
            "text": "#include \"rpc/server.h\"",
            "title": "rpc::server"
        },
        {
            "location": "/reference/#description_2",
            "text": "Implements a msgpack-rpc server. This is the main interfacing point with the library for creating servers.   The server maintains a registry of function bindings that it uses to dispatch calls. It also takes care of managing worker threads and TCP connections. The server does not start listening right after construction in order to allow binding functions before that. Use the  run  or  async_run  functions to start listening on the port.",
            "title": "Description"
        },
        {
            "location": "/reference/#public-functions_2",
            "text": "server (uint16_t port)     server (std::string const &address, uint16_t port)     ~server ()    void  run ()    void  async_run (std::size_t worker_threads=1)    void  bind (std::string const &name, F func)    void  suppress_exceptions (bool suppress)    void  stop ()    void  close_sessions ()",
            "title": "Public functions"
        },
        {
            "location": "/reference/#parameters_4",
            "text": "port  The port number to listen on.",
            "title": "Parameters"
        },
        {
            "location": "/reference/#parameters_5",
            "text": "port  The port number to listen on.",
            "title": "Parameters"
        },
        {
            "location": "/reference/#details_4",
            "text": "When the server is destroyed, all ongoin sessions are closed gracefully.",
            "title": "Details"
        },
        {
            "location": "/reference/#details_5",
            "text": "First and foremost, running the event loop causes the server to start listening on the specified port. Also, as connections are established and calls are made by clients, the server executes the calls as part of this call. This means that the handlers are executed on the thread that calls  run . Reads and writes are initiated by this function",
            "title": "Details"
        },
        {
            "location": "/reference/#parameters_6",
            "text": "worker_threads  The number of worker threads to start.",
            "title": "Parameters"
        },
        {
            "location": "/reference/#details_6",
            "text": "This function behaves similarly to  run , except the event loop is optionally started on different threads. Effectively this sets up a worker thread pool for the server. Handlers will be executed on one of the threads.",
            "title": "Details"
        },
        {
            "location": "/reference/#template-parameters_3",
            "text": "F  The type of the functor.",
            "title": "Template parameters"
        },
        {
            "location": "/reference/#parameters_7",
            "text": "name  The name of the functor.   func  The functor to bind.",
            "title": "Parameters"
        },
        {
            "location": "/reference/#details_7",
            "text": "This function template accepts a wide range of callables. The arguments and return types of these callables should be serializable by msgpack.  bind  effectively generates a suitable, light-weight compile-time wrapper for the functor.",
            "title": "Details"
        },
        {
            "location": "/reference/#rpcthis_handler_t",
            "text": "#include \"rpc/this_handler.h\"",
            "title": "rpc::this_handler_t"
        },
        {
            "location": "/reference/#description_3",
            "text": "Encapsulates information about the currently executing handler. This is the interface through which bound functions may return errors, arbitrary type responses or prohibit sending a response.   To obtain a  this_handler_t  object that corresponds to the currently executing handler, use the  rpc::this_handler()  free function. Any changes performed through the  this_handler  will only be in affect during the current call. It is safe to obtain multiple  this_handler s from concurrently executing handlers. Each object is unique to the current thread.",
            "title": "Description"
        },
        {
            "location": "/reference/#public-functions_3",
            "text": "void  respond_error (T &&err_obj)    void  respond (T &&resp_obj)    void  disable_response ()    void  enable_response ()    void  clear ()",
            "title": "Public functions"
        },
        {
            "location": "/reference/#template-parameters_4",
            "text": "T  The type of the error object.",
            "title": "Template parameters"
        },
        {
            "location": "/reference/#parameters_8",
            "text": "err_obj  The error object. This can be anything that is possible to encode with messagepack (even custom structures).",
            "title": "Parameters"
        },
        {
            "location": "/reference/#details_8",
            "text": "Internally, this function throws an exception, i.e. the control flow is interrupted at the point of this call.",
            "title": "Details"
        },
        {
            "location": "/reference/#template-parameters_5",
            "text": "T  The type of the response object.",
            "title": "Template parameters"
        },
        {
            "location": "/reference/#parameters_9",
            "text": "resp_obj  The response object. This can be anything that is possible to encode with messagepack (even custom structures).",
            "title": "Parameters"
        },
        {
            "location": "/reference/#details_9",
            "text": "Internally, this function throws an exception, i.e. the control flow is interrupted at the point of this call.   Warn  The normal return value of the function (if any) will be ignored if a special response is set.",
            "title": "Details"
        },
        {
            "location": "/reference/#rpcthis_server_t",
            "text": "#include \"rpc/this_server.h\"",
            "title": "rpc::this_server_t"
        },
        {
            "location": "/reference/#description_4",
            "text": "Allows controlling the server instance from the currently executing handler.",
            "title": "Description"
        },
        {
            "location": "/reference/#public-functions_4",
            "text": "void  stop ()    void  cancel_stop ()",
            "title": "Public functions"
        },
        {
            "location": "/reference/#details_10",
            "text": "Stopping only takes effect after leaving the handler normally.",
            "title": "Details"
        },
        {
            "location": "/reference/#rpcthis_session_t",
            "text": "#include \"rpc/this_session.h\"",
            "title": "rpc::this_session_t"
        },
        {
            "location": "/reference/#description_5",
            "text": "Encapsulates information about the server session/connection this handler is running in. This is the interface through which bound functions may interact with the session.   A session represents a connection on the server that corresponds to a single client.",
            "title": "Description"
        },
        {
            "location": "/reference/#public-functions_5",
            "text": "void  post_exit ()",
            "title": "Public functions"
        }
    ]
}